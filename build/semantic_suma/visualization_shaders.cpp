// GLOW_CACHE V10
// This file is automatically generated. All changes will be lost when calling cmake.

#include <iostream>
#include <glow/GlShaderCache.h>

namespace visualization_shaders {
class CacheInitalizer {
 public:
   CacheInitalizer() {
     glow::GlShaderCache& cache = glow::GlShaderCache::getInstance();
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/draw_normalmap3d.geom", "#version 330 core\n\n/**\n *  \author behley\n **/\n\nlayout(points) in;\nlayout(line_strip, max_vertices = 2) out;\n\nin VS_OUT {\n  bool valid;\n  vec4 normal;\n  vec4 color;\n} gs_in[];\n\nout vec4 color;\n\nvoid main()\n{\n  if(gs_in[0].valid)\n  {\n    color = gs_in[0].color;\n    gl_Position = gl_in[0].gl_Position;\n    EmitVertex();\n    \n    gl_Position = gl_in[0].gl_Position + 0.1 * gs_in[0].normal;\n    EmitVertex();\n    \n    EndPrimitive();\n  }\n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/draw_normalmap3d.vert", "#version 330 core\n\n/**\n *  \author behley\n **/\n\nlayout (location = 0) in vec2 tex_position;\n\nuniform sampler2DRect texVertexMap;\nuniform sampler2DRect texNormalMap;\n\nuniform mat4 mvp;\nuniform mat4 mvp_inv_t;\n\nout VS_OUT {\n  bool valid;\n  vec4 normal;\n  vec4 color;\n} vs_out;\n\nvoid main()\n{\n\n  gl_Position = mvp * vec4(texture(texVertexMap, tex_position).rgb, 1.0);\n  \n  \n  vs_out.valid = (texture(texNormalMap, tex_position).w > 0.5f);\n  vs_out.normal = mvp_inv_t * vec4(texture(texNormalMap, tex_position).rgb, 0.0f);\n  vs_out.color = vec4(abs(texture(texNormalMap, tex_position).rgb), 1.0f);\n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/draw_vertexmap3d.vert", "#version 330 core\n\n/**\n *  \author behley\n **/\n\nlayout (location = 0) in vec2 tex_position;\n\nuniform sampler2DRect texVertexMap;\nuniform sampler2DRect texResidualMap;\nuniform mat4 mvp;\n\nuniform int colorMode; // 0 - depth grey, 1 - hsv, 2 - red/depth, 3 - residual, 4 - outlier\nuniform vec4 customColor;\n\nout vec4 color;\n\n// source: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    \n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main()\n{\n  vec4 coords = vec4(texture(texVertexMap, tex_position).rgb, 1.0);\n  vec4 residuals = texture(texResidualMap, tex_position).rgba;\n  float depth = length(coords.xyz)/50.0f; \n  \n  gl_Position = mvp * coords;\n  \n  color = vec4(0.0f, 0.0f, 0.0f, 1.0f);\n  \n  if(colorMode == 0) color = vec4(depth, depth, depth, 1.0);\n  else if(colorMode == 1) color = vec4(hsv2rgb(vec3(depth, 1.0, 1.0)), 1.0);\n  else if(colorMode == 2) color = vec4(depth, 0, 0, 1.0);\n  else if(colorMode == 3) color = vec4(hsv2rgb(vec3(abs(residuals.g), 1.0, 1.0)), 1.0);\n  else if(colorMode == 4) {\n    if(int(residuals.a) < 0.5) color = vec4(1,0,0,1);\n    else color = vec4(0,1,0,1);\n  }\n  else if(colorMode == 5)\n  {\n    color = vec4(hsv2rgb(vec3(residuals.b, 1.0, 1.0)), 1.0);\n  }\n  else if(colorMode == 6)\n  {\n    if(residuals.a < -2.0) color = vec4(1,0,0,1);\n    else color = vec4(0,1,0,1);\n  }\n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/draw_depthimg.frag", "#version 330 core\n\n/**\n *  \author behley\n **/\n\nin vec2 texCoords;\nout vec4 color;\n\nuniform int colorMode; // 0 - intensity, 1 - hsv, 2 - raw \nuniform sampler2DRect depthTexture;\n\nuniform bool markInvalidDepthValues;\nuniform bool filterDepth;\nuniform float minDepth;\nuniform float maxDepth;\n\n\n\n// source: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    \n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nconst vec4 rviridis = vec4(2.90912735, -2.14404531, 0.04439198,  0.29390206);\nconst vec4 gviridis = vec4(-0.17293242, -0.16906214,  1.24131122,  0.01871256);\nconst vec4 bviridis = vec4(0.17848859, -1.72405244,  1.23042564,  0.34479632);\n\n// approximate version of viridis colormap.\nvec3 viridis(float t)\n{\n  vec4 tt = vec4(t*t*t, t*t, t, 1.0);\n  return vec3(dot(tt, rviridis), dot(tt, gviridis), dot(tt, bviridis)); \n}\n\n\nvoid main()\n{\n  float depth = length(texture(depthTexture, texCoords * textureSize(depthTexture)).xyz);\n  bool valid = bool(texture(depthTexture, texCoords * textureSize(depthTexture)).w);\n  \n  color = vec4(0.0, 0.0, 0.0, 1.0); // default color.\n  \n  if(!valid && markInvalidDepthValues)\n  {\n    color = vec4(1.0, 0.0, 0.0, 1.0);\n  }\n  else\n  {\n    if(filterDepth && (depth < minDepth || depth > maxDepth))\n    {\n      color = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    else\n    {\n      if(filterDepth && colorMode != 2) depth = (depth - minDepth) / (maxDepth-minDepth); \n      else if(colorMode != 2) depth = depth/50.0f;\n  \n      if(colorMode == 0) color = vec4(viridis(depth), 1.0);\n      else if(colorMode == 1) color = vec4(hsv2rgb(vec3(depth, 1.0, 1.0)), 1.0);\n      else if(colorMode == 2) color = vec4(depth, 0, 0, 1.0);\n    }\n  }\n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/draw_normalmap.frag", "#version 330 core\n\n/**\n *  \author behley\n **/\n\nin vec2 texCoords;\nout vec4 color;\n\nuniform sampler2DRect screenTexture;\nconst vec4 invalid = vec4(0.0, 0.0, 0.0f, 1.0f);\n\nvoid main()\n{ \n  color = abs(texture(screenTexture, texCoords * textureSize(screenTexture)));\n  if(color.w < 0.5f) color = invalid;\n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/draw_residuals.frag", "#version 330 core\n\n/**\n *  \author behley\n **/\n\nin vec2 texCoords;\nout vec4 color;\n\n\nuniform sampler2DRect residualmap;\n\n// source: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    \n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nconst vec4 rviridis = vec4(2.90912735, -2.14404531, 0.04439198,  0.29390206);\nconst vec4 gviridis = vec4(-0.17293242, -0.16906214,  1.24131122,  0.01871256);\nconst vec4 bviridis = vec4(0.17848859, -1.72405244,  1.23042564,  0.34479632);\n\n// approximate version of viridis colormap.\nvec3 viridis(float t)\n{\n  vec4 tt = vec4(t*t*t, t*t, t, 1.0);\n  return vec3(dot(tt, rviridis), dot(tt, gviridis), dot(tt, bviridis)); \n}\n\n\nvoid main()\n{\n  vec4 residual = texture(residualmap, texCoords * textureSize(residualmap));\n  //color = vec4(viridis(clamp(abs(residual.y) / 2.0, 0.0, 1.0)), 1.0);\n  if(residual.w > 0.5 && residual.x > 0.5) color = vec4(0,1,0,1);\n  else if(residual.w < -1.5)  color = vec4(1,0,0,1);\n  else if(residual.w < -0.5) color = vec4(0,0,1,1);\n  else if(residual.x < 0.5) color = vec4(0,0,0,1);\n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/draw_mesh.vert", "#version 330\n\n/**\n *  \author behley\n **/\n\nlayout (location = 0) in vec4 position_in;\nlayout (location = 1) in vec4 normal_in;\n\nuniform mat4 model_mat;   // model matrix.\nuniform mat4 normal_mat;  // transformation of normals to world coordinates.\nuniform mat4 mvp;         // model-view-projection matrix. (applied p*v*m)\n\nout vec4 pos;\nout vec4 normal;\n\nvoid main()\n{\n  gl_Position = mvp * position_in;\n  pos = model_mat * position_in;\n  normal = normal_mat * normal_in;\n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/draw_mesh.frag", "#version 330\n\n/**\n *  \author behley\n **/\n\nin vec4 pos;\nin vec4 normal;\n\nstruct Light\n{\n  vec4 position; // directional lights have w == 0.\n  \n  vec3 ambient;\n  vec3 diffuse;\n  vec3 specular;\n};\n\nuniform int num_lights;\nuniform Light lights[10];\n\nuniform vec4 view_pos;\n\nstruct Material\n{\n  vec3 ambient;\n  vec3 diffuse;\n  vec3 specular;\n  vec3 emission;\n  \n  float shininess;\n  float alpha;\n};\n\nuniform Material material;\n\nout vec4 color;\n\n// see also http://learnopengl.com/#!Lighting/Materials\n\nvoid main()\n{\n  vec3 norm = normalize(vec3(normal));\n  vec3 view_dir = normalize((view_pos - pos).xyz);\n    \n  vec3 result = vec3(0);\n\n  for(int i = 0; i < num_lights; ++i)\n  {\n    // ambient:\n    vec3 ambient = lights[i].ambient * material.ambient;\n    \n    // diffuse:\n    vec3 light_dir = normalize(lights[i].position.xyz - pos.xyz);\n    if(lights[i].position.w < 0.0001) light_dir = normalize(-lights[i].position.xyz); // directional light.\n    float diff = abs(dot(norm, light_dir));\n    vec3 diffuse = lights[i].diffuse * (diff * material.diffuse); \n    \n    // specular:\n    vec3 reflect_dir = reflect(-light_dir, norm);\n    float spec = pow(max(dot(view_dir, reflect_dir), 0.0), material.shininess);\n    vec3 specular =  lights[i].specular * (spec * material.specular);\n    \n    // emission (seems good to apply for each light the emission; with this the emission part doesn't just depend\n    // on the number of lights:\n    result += ambient + diffuse + specular + material.emission;\n  }\n\n  color = vec4(result, material.alpha);\n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/draw_posegraph_edge.geom", "#version 330 core\n\n/**\n *  \author behley\n **/\n\nlayout(points) in;\nlayout(line_strip, max_vertices = 4) out;\n\nuniform mat4 from;\nuniform mat4 to;\nuniform mat4 measurement;\n\nuniform mat4 mvp;\nuniform mat4 mvp_inv_t;\n\nout vec4 color;\n\n// better solution would be to use instancing, but for now this hack will do it.\n\nvoid main()\n{\n  // edge connecting the  poses:\n  vec4 origin = vec4(0,0,0,1);\n  color = vec4(0.5, 0, 0.95, 1.0);\n  gl_Position = mvp * from * origin;\n  EmitVertex();\n    \n  gl_Position = mvp * to * origin;\n  EmitVertex();   \n  \n  EndPrimitive();\n  \n  color = vec4(1.0, 0.0, 0.0, 1.0);\n  vec4 tip = from * measurement * origin;\n      \n  gl_Position = mvp * tip;\n  EmitVertex();    \n  \n  color = vec4(0.0, 1.0, 0.0, 1.0);\n\n  gl_Position = mvp * (from * measurement * vec4(1,0,0,0) + tip);\n  EmitVertex();\n  EndPrimitive();\n  \n  \n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/laserscan.vert", "#version 330 core\n\n/**\n *  \author behley\n **/\n\nlayout (location = 0) in vec4 position;\nlayout (location = 1) in float remission;\n\nuniform mat4 mvp;\nuniform int pointColorMode; // 0 - black, 1 - remission, 2 - depth, 3 - custom color, 4 - remission in w coordinate.\nuniform vec4 customColor;\nuniform bool removeGround;\n\nout vec4 point_color;\n\n#include \"shader/color.glsl\"\n\nvoid main()\n{\n    if(removeGround)\n    {\n      if(position.z < -1.0) gl_Position = vec4(-10, -10, -10, 1);\n      else gl_Position = mvp * vec4(position.xyz, 1.0);\n    }\n    else\n    {\n      gl_Position = mvp * vec4(position.xyz, 1.0);\n    }\n    \n    if(pointColorMode == 1) \n    {\n      point_color = vec4(remission, remission, remission, 1.0f);\n    }\n    else if(pointColorMode == 2)\n    {\n      float depth = length(vec3(position.x, position.y, position.z));\n      vec3 hsv = hsv2rgb(vec3(depth/50.0, 1.0, 1.0));\n      point_color = vec4(hsv, 1.0);\n    }\n    else if(pointColorMode == 3)\n    {\n      //vec3 hsv = rgb2hsv(customColor.xyz);\n      point_color = customColor;//vec4(hsv2rgb(vec3(hsv.x, 1.0, remission)), 1.0f);\n    }\n    else if(pointColorMode == 4)\n    {\n      point_color = vec4(position.w, position.w, position.w, 1.0f); \n    }\n    else if(pointColorMode == 5)\n    {\n      vec3 hsv = rgb2hsv(customColor.xyz);\n      point_color = vec4(hsv2rgb(vec3(hsv.x, 1.0, max(2*position.w, 0.5))), 1.0f);\n    }\n    else if(pointColorMode == 6)\n    {\n      vec3 hsv = rgb2hsv(customColor.xyz);\n      point_color = vec4(hsv2rgb(vec3(hsv.x, 1.0, max(remission, 0.3))), 1.0f);\n    }\n    else if(pointColorMode == 7)\n    {\n      point_color = vec4(hsv2rgb(vec3(position.z / 10.0, 1.0, max(2*position.w, 0.5))), 1.0f);\n    }\n    else\n    {\n      point_color = vec4(0.0f, 0.0f, 0.0f, 1.0f);\n    }\n    \n    \n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/laserscan.frag", "#version 330 core\n\n/**\n *  \author behley\n **/\n\nin vec4 point_color;\nout vec4 color;\n\nvoid main()\n{\n    color = point_color;\n} \n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/draw_semanticmap.frag", "#version 330 core\n\n/**\n *  \author Xieyuanli Chen\n **/\n\nin vec2 texCoords;\nout vec4 color;\n\nuniform sampler2DRect screenTexture;\nconst vec4 invalid = vec4(0.0, 0.0, 0.0f, 1.0f);\n\nvoid main()\n{\n  color = abs(texture(screenTexture, texCoords * textureSize(screenTexture)));\n  if(color.w < 0.5f) color = invalid;\n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/draw_semantic_colormap.frag", "#version 330 core\n\n/**\n *  \author Xieyuanli Chen\n **/\n\nin vec2 texCoords;\nout vec4 color;\n\nuniform sampler2DRect screenTexture;\nuniform sampler1D color_map; // for semantic maps\nconst vec4 invalid = vec4(0.0, 0.0, 0.0, 1.0);\n\nvoid main()\n{\n  vec4 semantic_label = texture(screenTexture, texCoords * textureSize(screenTexture));\n\n  if(semantic_label.x == 0.0 || semantic_label.w < 0.9) color = invalid;\n\n  else\n  {\n    float textureSize1d = 259.0f;\n    vec4 sfl_semantic = vec4(texture(color_map, semantic_label.x * 255.0f / textureSize1d).rgb, 1.0);\n    color = sfl_semantic;\n  }\n}\n");
   };
};

static CacheInitalizer __init__;
} // end namespace visualization_shaders