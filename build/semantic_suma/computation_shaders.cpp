// GLOW_CACHE V10
// This file is automatically generated. All changes will be lost when calling cmake.

#include <iostream>
#include <glow/GlShaderCache.h>

namespace computation_shaders {
class CacheInitalizer {
 public:
   CacheInitalizer() {
     glow::GlShaderCache& cache = glow::GlShaderCache::getInstance();
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/color.glsl", "/**\n *  \author behley\n **/\n\nconst vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\nconst vec4 GREEN = vec4(0.0, 1.0, 0.0, 1.0);\nconst vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\n\n// source: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// http://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n\n// source: elastic fusion https://github.com/mp3guy/ElasticFusion  &\n// http://stackoverflow.com/questions/6893302/decode-rgb-value-to-single-float-without-bit-shift-in-glsl\nfloat pack(vec3 c)\n{\n    int rgb = int(round(c.x * 255.0f));\n    rgb = (rgb << 8) + int(round(c.y * 255.0f));\n    rgb = (rgb << 8) + int(round(c.z * 255.0f));\n    return float(rgb);\n}\n\nvec3 unpack(float c)\n{\n    vec3 col;\n    col.x = float(int(c) >> 16 & 0xFF) / 255.0f;\n    col.y = float(int(c) >> 8 & 0xFF) / 255.0f;\n    col.z = float(int(c) & 0xFF) / 255.0f;\n    return col;\n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/color_map.glsl", "/**\n *  \author Xieyuanli Chen\n **/\n\n// semantic color map\nconst vec4 unlabeled = vec4(0, 0, 0, 0);\nconst vec4 outlier = vec4(0, 0, 255, 1);\nconst vec4 car = vec4(245, 150, 100, 10);\nconst vec4 bicycle = vec4(245, 230, 100, 11);\nconst vec4 bus = vec4(250, 80, 100, 13);\nconst vec4 motorcycle = vec4(150, 60, 30,15);\nconst vec4 on_rails = vec4(255, 0, 0, 16);\nconst vec4 truck = vec4(180, 30, 80, 18);\nconst vec4 other_vehicle = vec4(255, 0, 0, 20);\nconst vec4 person = vec4(30, 30, 255, 30);\nconst vec4 bicyclist = vec4(200, 40, 255, 31);\nconst vec4 motorcyclist = vec4(90, 30, 150, 32);\nconst vec4 road = vec4(255, 0, 255, 40);\nconst vec4 parking = vec4(255, 150, 255, 44);\nconst vec4 sidewalk = vec4(75, 0, 75, 48);\nconst vec4 other_ground = vec4(75, 0, 175, 49);\nconst vec4 building = vec4(0, 200, 255, 50);\nconst vec4 fence = vec4(50, 120, 255, 51);\nconst vec4 other_structure = vec4(0, 150, 255, 52);\nconst vec4 lane_marking = vec4(170, 255, 150, 60);\nconst vec4 vegetation = vec4(0, 175, 0, 70);\nconst vec4 trunk = vec4(0, 60, 135, 71);\nconst vec4 terrain = vec4(80, 240, 150, 72);\nconst vec4 pole = vec4(150, 240, 255, 80);\nconst vec4 traffic_sign = vec4(0, 0, 255, 81);\nconst vec4 other_object = vec4(255, 255, 50, 99);\nconst vec4 moving_car = vec4(245, 150, 100, 252);\nconst vec4 moving_bicyclist = vec4(255, 0, 0, 256);\nconst vec4 moving_person = vec4(200, 40, 255, 253);\nconst vec4 moving_motorcyclist = vec4(30, 30, 255, 254);\nconst vec4 moving_on_rails = vec4(90, 30, 150, 255);\nconst vec4 moving_bus = vec4(250, 80, 100, 257);\nconst vec4 moving_truck = vec4(180, 30, 80, 258);\nconst vec4 moving_other_vehicle = vec4(255, 0, 0, 259);\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/empty.vert", "#version 330 core\n\n/**\n *  \author behley\n **/\n\nvoid main()\n{\n\n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/empty.frag", "#version 330 core\n\n/**\n *  \author behley\n **/\n\n\nvoid main()\n{\n\n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/quad.geom", "#version 330 core\n\n/**\n *  \author behley\n **/\n\nlayout(points) in;\nlayout(triangle_strip, max_vertices = 4) out;\n\nout vec2 texCoords;\n\nvoid main() \n{\n    gl_Position = vec4(1.0, 1.0, 0.0, 1.0);\n    texCoords = vec2(1.0, 1.0);\n    EmitVertex();\n\n    gl_Position = vec4(-1.0, 1.0, 0.0, 1.0);\n    texCoords = vec2(0.0, 1.0); \n    EmitVertex();\n\n    gl_Position = vec4(1.0,-1.0, 0.0, 1.0);\n    texCoords = vec2(1.0, 0.0); \n    EmitVertex();\n\n    gl_Position = vec4(-1.0,-1.0, 0.0, 1.0);\n    texCoords = vec2(0.0, 0.0); \n    EmitVertex();\n\n    EndPrimitive(); \n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/quad_inverse.geom", "#version 330 core\n\n/**\n *  \author behley\n **/\n\nlayout(points) in;\nlayout(triangle_strip, max_vertices = 4) out;\n\nout vec2 texCoords;\n\nvoid main()\n{\n    gl_Position = vec4(1.0, 1.0, 0.0, 1.0);\n    texCoords = vec2(1.0, 0.0);\n    EmitVertex();\n\n    gl_Position = vec4(-1.0, 1.0, 0.0, 1.0);\n    texCoords = vec2(0.0, 0.0);\n    EmitVertex();\n\n    gl_Position = vec4(1.0,-1.0, 0.0, 1.0);\n    texCoords = vec2(1.0, 1.0);\n    EmitVertex();\n\n    gl_Position = vec4(-1.0,-1.0, 0.0, 1.0);\n    texCoords = vec2(0.0, 1.0);\n    EmitVertex();\n\n    EndPrimitive();\n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/passthrough.frag", "#version 330 core\n\n/**\n *  \author behley\n **/\n\nin vec4 color;\nout vec4 out_color;\n\nvoid main()\n{\n  out_color = color;\n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/Frame2Model_jacobians.frag", "#version 330\n\n/**\n *  \author behley\n **/\n\nin vec3 values;\n\n// layout (location = 0) \nout vec3 result;\n\nvoid main()\n{\n  // blending ensures that the sum is computed.\n  result = values;\n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/Frame2Model_jacobians.geom", "#version 330 core\n\n/**\n *  \author behley\n *\n *  \author Xieyuanli Chen\n **/\n\nlayout(points) in;\nlayout(points, max_vertices = 16) out;\n\nuniform sampler2DRect vertex_model;\nuniform sampler2DRect normal_model;\n\nuniform sampler2DRect vertex_data;\nuniform sampler2DRect normal_data;\n\nuniform sampler2DRect semantic_model; // [0,width]\nuniform sampler2DRect semantic_data;\n\nuniform float distance_thresh;\nuniform float angle_thresh;\n\nuniform mat4 pose;\nuniform float fov_up;\nuniform float fov_down;\nuniform int entries_per_kernel;\n\nconst float pi = 3.14159265358979323846f;\nconst float inv_pi = 0.31830988618379067154f;\nconst float pi_2 = 1.57079632679;\n\nuniform int iteration;\nuniform int weight_function; // 0 - none, 1 - huber, 2 - turkey, 3 - stability.\nuniform float factor;\n\nuniform float cutoff_threshold;\n\n#include \"shader/color_map.glsl\"\n\nin VS_OUT {\n  vec2 texCoords;\n} gs_in[];\n\nout vec3 values;\n\nvec2 mat_coords(int i, int j)\n{\n  // keep in mind that we only have OpenGLs coord system...\n  return vec2(2.0 * (j + 0.5) / 2.0 - 1.0, 2.0 * (i + 0.5) / 8.0 - 1.0);\n}\n\nvec2 project2model(vec4 vertex)\n{\n  vec2 tex_dim = textureSize(vertex_model);\n  float fov = abs(fov_up) + abs(fov_down);\n  float depth = length(vertex.xyz);\n  float yaw = atan(vertex.y, vertex.x);\n  float pitch = -asin(vertex.z / depth); // angle = acos((0,0,1) * p/||p||) - pi/2 = pi/2 - asin(x) + pi/2\n\n  float x = 0.5 * ((-yaw * inv_pi) + 1.0); // in [0, 1]\n  float y = 1.0 - (degrees(pitch) + fov_up) / fov; // in [0, 1]\n\n  return vec2(x, y)*tex_dim; // [0, w],  [0, h]\n}\n\nvoid main()\n{\n  vec2 tex_dim = textureSize(vertex_data);\n  vec2 model_dim = textureSize(vertex_model);\n\n  bool has_inlier = false;\n\n  // Idea: compute aggregated values, then submit values.\n\n  // store Jacobian in column-major order; store J^T*f in last row.\n\n  vec3 temp[16];\n  for(int i = 0; i < 16; ++i) temp[i] = vec3(0);\n\n  for(int e = 0; e < entries_per_kernel; ++e)\n  {\n    vec2 texCoords = gs_in[0].texCoords + vec2(e, 0);\n    if(texCoords.x >= tex_dim.x || texCoords.y >= tex_dim.y) continue;\n\n    vec2 img_coords = texCoords.xy / tex_dim;\n\n    float e_d = texture(vertex_data, texCoords).w + texture(normal_data, texCoords).w;\n    vec4 v_d = pose * vec4(texture(vertex_data, texCoords).xyz, 1.0);\n    vec4 n_d = pose * vec4(texture(normal_data, texCoords).xyz, 0.0); // assuming non-scaling transform\n\n    bool inlier = false;\n\n    vec2 idx = project2model(v_d);\n    if(idx.x < 0 || idx.x >= model_dim.x || idx.y < 0 || idx.y >= model_dim.y)\n    {\n      e_d = 0.0f;\n    }\n\n    float e_m = texture(vertex_model, idx).w + texture(normal_model, idx).w;\n    vec3 v_m = texture(vertex_model, idx).xyz;\n    vec3 n_m = texture(normal_model, idx).xyz;\n\n    // Reminder: use ifs instead of if(...) return; to avoid problemns with Intel cpu.\n    if((e_m > 1.5f) && (e_d > 1.5f))\n    {\n      has_inlier = true;\n\n      bool inlier = true;\n\n      if(length(v_m.xyz - v_d.xyz) > distance_thresh) inlier = false;\n      if(dot(n_m.xyz, n_d.xyz) < angle_thresh) inlier = false;\n\n      float residual = (dot(n_m.xyz, (v_d.xyz - v_m.xyz)));\n      vec3 n = n_m;\n      vec3 cp = cross(v_d.xyz, n_m.xyz);\n\n      float weight = 1.0;\n\n      if((weight_function == 4 || weight_function == 1))\n      {\n        // huber weighting.\n        if(abs(residual) > factor)\n        {\n          weight = factor / abs(residual);\n        }\n      }\n      else if(weight_function == 2 && iteration > 0)\n      {\n        // turkey bi-squared weighting:\n        if(abs(residual) > factor)\n        {\n          weight = 0;\n        }\n        else\n        {\n          float alpha = residual / factor;\n          weight = (1.0  - alpha * alpha);\n          weight = weight * weight;\n        }\n      }\n\n      // use semantic information during ICP\n      float data_label = texture(semantic_data, texCoords).x * 255.0;\n      float data_label_prob = texture(semantic_data, texCoords).w;\n      float model_label = texture(semantic_model, idx).x * 255.0;\n\n      if( model_label == car.w || model_label == bicycle.w ||\n          model_label == bus.w || model_label == motorcycle.w||\n          model_label == truck.w|| model_label == other_vehicle.w||\n          model_label == person.w||\n          model_label == bicyclist.w || model_label == motorcyclist.w)\n      {\n        if(round(data_label) != round(model_label))\n           weight *= (1 - data_label_prob);\n        else\n           weight *= data_label_prob;\n      }\n\n      if(inlier)\n      {\n\n        temp[0] += weight * n.x * n;\n        temp[1] += weight * n.y * n;\n        temp[2] += weight * n.z * n;\n        temp[3] += weight * cp.x * n;\n        temp[4] += weight * cp.y * n;\n        temp[5] += weight * cp.z * n;\n\n        temp[6] += weight * n.x * cp;\n        temp[7] += weight * n.y * cp;\n        temp[8] += weight * n.z * cp;\n        temp[9] += weight * cp.x * cp;\n        temp[10] += weight * cp.y * cp;\n        temp[11] += weight * cp.z * cp;\n\n        // compute J^T * W * f => 2 vertices\n\n        temp[12] += weight * residual * n;\n\n        temp[13] += weight * residual * cp;\n\n        temp[14].x += 1.0f; // terms in error function (inlier + outlier)\n        temp[14].y += weight * residual * residual; // residual\n\n        temp[15].x += weight * residual * residual; // inlier residual\n\n      }\n      else\n      {\n        // was cut-off due to gross outlier rejection.\n        temp[14].x += 1.0f; // terms.\n        temp[14].y += weight * residual * residual; // \"outlier\" residual.\n        temp[14].z += 1.0f;// num_outliers.\n      }\n    }\n    else\n    {\n      temp[15].y += 1.0; // invalid count.\n    }\n\n  }\n\n  // SUBMISSION:\n\n  if(has_inlier)\n  {\n    for(int i = 0; i < 6; ++i)\n    {\n      gl_Position = vec4(mat_coords(i, 0), 0.0, 1.0);\n      values = temp[i];\n\n      EmitVertex();\n      EndPrimitive();\n\n      gl_Position = vec4(mat_coords(i, 1), 0.0, 1.0);\n      values = temp[i + 6];\n\n      EmitVertex();\n      EndPrimitive();\n    }\n  }\n\n  gl_Position = vec4(mat_coords(6, 0), 0.0, 1.0);\n  values = temp[12];\n\n  EmitVertex();\n  EndPrimitive();\n\n  gl_Position = vec4(mat_coords(6, 1), 0.0, 1.0);\n  values = temp[13];\n\n  EmitVertex();\n  EndPrimitive();\n\n  gl_Position = vec4(mat_coords(7, 0), 0.0, 1.0);\n  values = temp[14];\n\n  EmitVertex();\n  EndPrimitive();\n\n  gl_Position = vec4(mat_coords(7, 1), 0.0, 1.0);\n  values = temp[15];\n\n  EmitVertex();\n  EndPrimitive();\n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/Frame2Model_jacobians.vert", "#version 330\n\n/** \brief Computation of residual & Jacobian from given model vertices & data vertices.\n *  \n *  Generating everything needed for computation of (weighted) Jacobian products. \n *\n *  Computation happens in the geometry shader, since this turned out to be more productive.\n *   \n *\n *  \author behley\n **/\n\nlayout (location = 0) in vec2 texCoords;\n\nout VS_OUT {\n  vec2 texCoords;\n} vs_out;\n  \nvoid main()\n{\n  gl_Position = vec4(0.5);\n  vs_out.texCoords = texCoords;\n}");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/render_surfels.frag", "#version 330 core\n\n/**\n *  \author behley\n *\n *  \author Xieyuanli Chen\n **/\n\nin vec2 texCoords;\nin vec4 vertex;\nin vec4 normal;\nin vec4 semantic;\nin float confidence;\n\nlayout (location = 0) out vec4 vertexmap;\nlayout (location = 1) out vec4 normalmap;\nlayout (location = 2) out vec4 semantic_rangemap;\n\nvoid main()\n{\n\n if(dot(texCoords, texCoords) > 1.0f)\n {\n  vertexmap = vec4(0);\n  normalmap = vec4(0);\n  semantic_rangemap = vec4(0);\n  discard;\n }\n\n vertexmap = vec4(vertex.xyz, 1.0);\n normalmap = normal;\n semantic_rangemap = semantic;\n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/render_surfels.geom", "#version 330 core\n\n/**\n *  \author behley\n *\n *  \author Xieyuanli Chen\n **/\n\nlayout(points) in;\nlayout(triangle_strip, max_vertices = 6) out;\n\nin SURFEL\n{\n  vec4 position;\n  float radius;\n  vec4 normal;\n  float confidence;\n  int index;\n  int timestamp;\n  int creation_timestamp;\n  vec4 semantic_map;\n} gs_in[];\n\nout vec2 texCoords;\nout vec4 normal;\nout vec4 vertex;\nout vec4 semantic;\nout float confidence;\n\nuniform float fov_up;\nuniform float fov_down;\nuniform float max_depth;\nuniform float min_depth;\n\nuniform float conf_threshold;\nuniform int timestamp_threshold;\nuniform bool render_old_surfels;\nuniform bool use_stability;\n\nconst float pi = 3.14159265358979323846f;\nconst float inv_pi = 0.31830988618379067154f;\nconst float pi_2 = 1.57079632679;\n\n\nvec3 project2model(vec4 position)\n{\n  float fov = abs(fov_up) + abs(fov_down);\n  float depth = length(position.xyz);\n  float yaw = atan(position.y, position.x);\n  float pitch = -asin(position.z / depth);\n\n  float x = 0.5 * ((-yaw * inv_pi) + 1.0); // in [0, 1]\n  float y = (1.0 - (degrees(pitch) + fov_up) / fov); // in [0, 1]\n  float z = (depth - min_depth) / (max_depth - min_depth); // in [0, 1]\n\n  return vec3(x, y, z);\n}\n\nvec3 project2model(vec4 position, vec3 center_pixel)\n{\n  float fov = abs(fov_up) + abs(fov_down);\n  float depth = length(position.xyz);\n  float yaw = atan(position.y, position.x);\n  float pitch = -asin(position.z / depth);\n\n  float x = 0.5 * ((-yaw * inv_pi) + 1.0); // in [0, 1]\n  // FIXME: find better solution for wrap around:\n  if(center_pixel.x - x > 0.5) x += 1.0;\n  if(x - center_pixel.x > 0.5) x -= 1.0;\n  float y = (1.0 - (degrees(pitch) + fov_up) / fov); // in [0, 1]\n  float z = (depth - min_depth) / (max_depth - min_depth); // in [0, 1]\n\n  return vec3(x, y, z);\n}\n\nvoid main()\n{\n  vec4 p = gs_in[0].position;\n  vec4 n = gs_in[0].normal;\n  vec4 u = normalize(vec4(n.y - n.z, -n.x, n.x, 0.0f));\n  vec4 v = vec4(normalize(cross(n.xyz, u.xyz)), 0.0f);\n  float r = gs_in[0].radius;\n\n  bool visible = (dot(n.xyz, -p.xyz / length(p.xyz)) > 0.01);\n\n  vec3 pp = project2model(p);\n  if(visible && all(greaterThanEqual(pp, vec3(0))) &&  all(lessThan(pp, vec3(1))) && (!use_stability || gs_in[0].confidence > conf_threshold))\n  {\n    //p_stable = 1.0 - 1.0 / (1.0 + exp(gs_in[0].confidence));\n    bool valid = (render_old_surfels && (gs_in[0].creation_timestamp <  timestamp_threshold));\n    valid = valid || (!render_old_surfels && (gs_in[0].creation_timestamp >=  timestamp_threshold || gs_in[0].timestamp >= timestamp_threshold));\n\n    if(valid)\n    {\n      vertex = vec4(p.xyz, 1.0f);\n      normal = vec4(n.xyz, 1.0f);\n      semantic = gs_in[0].semantic_map;\n      //index = gs_in[0].index + 1;\n      confidence = gs_in[0].confidence;\n\n      vec4 ru = r * u;\n      vec4 rv = r * v;\n\n      gl_Position = vec4(2.0 * project2model(p - ru - rv, pp) - 1.0, 1.0f);\n      texCoords = vec2(-1.0, -1.0);\n      EmitVertex();\n\n      gl_Position = vec4(2.0 * project2model(p + ru - rv, pp) - 1.0, 1.0f);\n      texCoords = vec2(1.0, -1.0);\n      EmitVertex();\n\n      gl_Position = vec4(2.0 * project2model(p - ru + rv, pp) - 1.0, 1.0f);\n      texCoords = vec2(-1.0, 1.0);\n      EmitVertex();\n\n      gl_Position = vec4(2.0 * project2model(p + ru + rv, pp) - 1.0, 1.0f);\n      texCoords = vec2(1.0, 1.0);\n\n      EmitVertex();\n      EndPrimitive();\n    }\n  }\n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/render_surfels.vert", "#version 330 core\n\n/**\n *  \author behley\n *\n *  \author Xieyuanli Chen\n **/\n\n// \brief essentially the same as drawing, but with projected coordinates.\n\n// Replicate surfels on borders?\n\nlayout (location = 0) in vec4 position_radius;\nlayout (location = 1) in vec4 normal_confidence;\nlayout (location = 2) in int timestamp;\nlayout (location = 3) in vec3 surfel_color_weight_count;\nlayout (location = 4) in vec4 surfel_semantic_map;\n\nuniform mat4 inv_pose;\n\nuniform samplerBuffer poseBuffer;\n\nout SURFEL\n{\n  vec4 position;\n  float radius;\n  vec4 normal;\n  float confidence;\n  int index;\n  int timestamp;\n  int creation_timestamp;\n  vec4 semantic_map;\n} vs_out;\n\nmat4 get_pose(int t)\n{\n  int offset = 4 * t;\n  return mat4(texelFetch(poseBuffer, offset), texelFetch(poseBuffer, offset + 1),\n              texelFetch(poseBuffer, offset + 2), texelFetch(poseBuffer, offset+3));\n}\n\nvoid main()\n{\n  mat4 surfelPose = get_pose(int(surfel_color_weight_count.z));\n\n  vs_out.position = inv_pose * surfelPose * vec4(position_radius.xyz, 1.0f);\n  vs_out.radius = position_radius.w;\n  vs_out.normal = inv_pose * surfelPose * vec4(normal_confidence.xyz, 0.0f);\n  vs_out.confidence = normal_confidence.w;\n  vs_out.index = gl_VertexID;\n  vs_out.timestamp = timestamp;\n  vs_out.creation_timestamp = int(surfel_color_weight_count.z);\n  vs_out.semantic_map = surfel_semantic_map;\n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/render_compose.frag", "#version 330 core\n\n/**\n *  \author behley\n *\n *  \author Xieyuanli Chen\n **/\n\nin vec2 texCoords;\n\nlayout (location = 0) out vec4 vertexmap;\nlayout (location = 1) out vec4 normalmap;\nlayout (location = 2) out vec4 semanticmap;\n\n\nuniform sampler2DRect old_vertexmap;\nuniform sampler2DRect old_normalmap;\nuniform sampler2DRect new_vertexmap;\nuniform sampler2DRect new_normalmap;\nuniform sampler2DRect old_semanticmap;\nuniform sampler2DRect new_semanticmap;\n\nuniform float max_distance; // maximum distance of old vertices to consider.\n\n\nvoid main()\n{\n  vec2 dim = textureSize(new_vertexmap);\n  vec2 img_coords = texCoords * dim;\n\n  vertexmap = texture(new_vertexmap, img_coords);\n  normalmap = texture(new_normalmap, img_coords);\n  semanticmap = texture(new_semanticmap, img_coords);\n\n  vec4 old_vertex = texture(old_vertexmap, img_coords);\n  vec4 old_normal = texture(old_normalmap, img_coords);\n  vec4 old_semantic = texture(old_semanticmap, img_coords);\n\n  bool valid = (old_vertex.w > 0.5f && old_normal.w > 0.5f);\n  bool new_valid = (vertexmap.w > 0.5f && normalmap.w > 0.5f);\n\n  if(!new_valid && valid && (vertexmap.w < 0.5f || length(vertexmap.xyz - old_vertex.xyz) < max_distance))\n  {\n     vertexmap = old_vertex;\n     normalmap = old_normal;\n     semanticmap = old_semantic;\n  }\n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/update_surfels.vert", "#version 330 core\n\n/**\n *  \author behley\n *\n *  \author Xieyuanli Chen\n **/\n\n#include \"shader/color.glsl\"\n#include \"shader/color_map.glsl\"\n\nlayout (location = 0) in vec4 surfel_position_radius;\nlayout (location = 1) in vec4 surfel_normal_confidence;\nlayout (location = 2) in int  surfel_timestamp;\nlayout (location = 3) in vec3 surfel_color_weight_count;\nlayout (location = 4) in vec4 surfel_semantic_map;\n\nuniform mat4 pose;\nuniform mat4 inv_pose;\nuniform int  timestamp;\n\nuniform float distance_thresh;\nuniform float angle_thresh;\n\nuniform sampler2DRect vertex_map;\nuniform sampler2DRect normal_map;\nuniform sampler2DRect radiusConfidence_map;\nuniform sampler2DRect index_map;\nuniform sampler2DRect semantic_map_in;\n\nuniform samplerBuffer poseBuffer;\n\nuniform float width;\nuniform float height;\nuniform float pixel_size;\n\nuniform float fov_up;\nuniform float fov_down;\nuniform float max_depth;\nuniform float min_depth;\nuniform int unstable_age;\nuniform float confidence_threshold;\nuniform int confidence_mode;\n\nuniform float p_stable;\nuniform float p_unstable;\nuniform float p_prior;\nuniform float log_unstable; // log odds of p_unstable log(p_unstable/(1-p_unstable));\nuniform float log_prior;    // log odds of p_prior.\nuniform float sigma_angle;\nuniform float sigma_distance;\nuniform float min_radius;\nuniform bool update_always;\nuniform bool use_stability;\n\nuniform int weighting_scheme; // 0 - exponential, 1 - cumulative, 2 - cumulative/weighted\nuniform float max_weight;\nuniform int averaging_scheme; // 0 - normal, 1 - advanced/push?\n\nconst float sqrt2 = 1.41421356237f;\nconst float pi = 3.14159265358979323846f;\nconst float inv_pi = 0.31830988618379067154f;\nconst float pi_2 = 1.57079632679;\n\nuniform int active_timestamps;\n\nout SURFEL\n{\n  bool valid;\n  vec4 position_radius;\n  vec4 normal_confidence;\n  int timestamp;\n  vec3 color_weight_count;\n  vec4 semantic_map; // for semantic map\n} vs_out;\n\nvec3 projectSpherical(vec3 position)\n{\n  float fov = abs(fov_up) + abs(fov_down);\n  float depth = length(position.xyz);\n  float yaw = atan(position.y, position.x);\n  float pitch = -asin(position.z / depth);\n\n  float x = 0.5 * ((-yaw * inv_pi) + 1.0); // in [0, 1]\n  float y = (1.0 - (degrees(pitch) + fov_up) / fov); // in [0, 1]\n  float z = (depth - min_depth) / (max_depth - min_depth); // in [0, 1]\n\n  // half-pixel coordinates.\n  x = (floor(x * width) + 0.5);\n  y = (floor(y * height) + 0.5);\n\n  return vec3(x, y, z);\n}\n\nvec4 centerize(vec2 img_coords, vec3 position, vec3 normal, vec2 dim)\n{\n  float fov = abs(fov_up) + abs(fov_down);\n\n  float x05 = (floor(img_coords.x) + 0.5f) / dim.x;\n  float y05 = (floor(img_coords.y) + 0.5f) / dim.y;\n\n  float theta = radians((1.0f - y05) * fov - fov_up) + pi_2;\n  float phi = -(2.0 * x05 - 1.0f) * pi;\n\n  vec3 nu = vec3(sin(theta)*cos(phi), sin(theta)*sin(phi), cos(theta));\n\n  float r = dot(normal, position) / dot(normal, nu);\n\n  return vec4(r * nu, 1.0);\n}\n\n\nvec3 slerp(vec3 v0, vec3 v1, float weight)\n{\n\n  float omega = acos(dot(normalize(v0), normalize(v1)));\n\n  // weight is actually (1.0 - t), therefore inverted.\n  float eta = 1.0 / sin(omega);\n  float w0 = eta * sin(weight * omega);\n  float w1 = eta * sin((1.-weight)* omega);\n\n  return w0 * v0 + w1 * v1;\n}\n\nfloat get_radius(vec4 vertex, vec4 normal, float pixel_size)\n{\n  float d = length(vertex.xyz);\n\n  return  1.41 * d * pixel_size / clamp(dot(normal.xyz, -vertex.xyz / d), 0.5, 1.0);\n}\n\nmat4 get_pose(int timestamp)\n{\n  int offset = 4 * timestamp;\n  return mat4(texelFetch(poseBuffer, offset), texelFetch(poseBuffer, offset + 1),\n              texelFetch(poseBuffer, offset + 2), texelFetch(poseBuffer, offset + 3));\n}\n\nvoid main()\n{\n  const float upper_stability_bound = 20.0;\n  int surfel_age = timestamp - surfel_timestamp;\n\n  int creation_timestamp = int(surfel_color_weight_count.z);\n  // read column-wise surfel pose from texture buffer:\n  mat4 surfelPose = get_pose(creation_timestamp);\n\n\n  vec3 old_position = (surfelPose * vec4(surfel_position_radius.xyz, 1)).xyz;\n  vec3 old_normal = (surfelPose* vec4(surfel_normal_confidence.xyz, 0)).xyz;\n  float old_radius = surfel_position_radius.w;\n  float old_confidence = surfel_normal_confidence.w;\n  float old_weight = surfel_color_weight_count.y;\n\n  vs_out.valid = true;\n  if(old_confidence < confidence_threshold && use_stability) vs_out.valid = (surfel_age < unstable_age);\n  vs_out.position_radius = surfel_position_radius;\n  vs_out.normal_confidence = surfel_normal_confidence;\n  vs_out.timestamp = surfel_timestamp;\n  vs_out.color_weight_count = surfel_color_weight_count;\n  vs_out.color_weight_count.x = pack(vec3(0.3, 0.3, 0.3));\n\n  vs_out.semantic_map = surfel_semantic_map; // for semantic map\n\n  vec4 vertex = inv_pose * vec4(old_position, 1.0);\n  vec4 normal = normalize(inv_pose * vec4(old_normal, 0.0));\n\n  bool visible = (dot(normal.xyz, -vertex.xyz / length(vertex.xyz)) > 0.00);\n  vec3 img_coords = projectSpherical(vertex.xyz);\n  vec3 dim = vec3(width, height, 1);\n  gl_Position = vec4(-10.0);\n  bool valid = (texture(vertex_map, img_coords.xy).w > 0.5f) && (texture(normal_map, img_coords.xy).w > 0.5f);\n  bool inside = all(lessThan(img_coords, dim)) && !(all(lessThan(img_coords, vec3(0))));\n\n  float penalty = 0.0;\n\n  float update_confidence = log_prior;\n\n  if(valid && inside && visible)\n  {\n    // detect and renalize outliers\n    float data_label = texture(semantic_map_in, img_coords.xy).x * 255.0;\n    float data_prob = texture(semantic_map_in, img_coords.xy).w;\n    float model_label = surfel_semantic_map.x * 255.0;\n    float model_prob = surfel_semantic_map.w;\n    if(round(data_label) != round(model_label))\n    {\n      if( model_label == car.w || model_label == bicycle.w ||\n          model_label == bus.w || model_label == motorcycle.w||\n          model_label == truck.w|| model_label == other_vehicle.w||\n          model_label == person.w||\n          model_label == bicyclist.w || model_label == motorcyclist.w)\n          penalty = 1.0;\n    }\n\n    mat4 surfelPose_inv = inverse(surfelPose);\n\n    // Check if surfel and measurment are compatible.\n    vec3 v = texture(vertex_map, img_coords.xy).xyz;\n    vec3 n = texture(normal_map, img_coords.xy).xyz;\n    vec4 v_global = pose * vec4(v, 1.0f);\n    // Note: We assume non-scaling transformation, det(pose) = 1.0. Therefore Rot(pose^T^-1) = Rot(pose).\n    vec4 n_global = normalize(pose * vec4(n, 0.0f));\n\n    float depth = length(v);\n\n    vec3 view_dir = -v/length(v);\n\n    float distance = abs(dot(old_normal.xyz, v_global.xyz - old_position.xyz)); // distance(v_global.xyz, old_position.xyz);\n    float angle = length(cross(n_global.xyz, old_normal.xyz));\n\n    float new_radius = texture(radiusConfidence_map, img_coords.xy).x;\n    float new_confidence = texture(radiusConfidence_map, img_coords.xy).y;\n\n    // measurement is compatible, update conf & timestamp, but integrate measurment only if new radius is smaller!\n    if((distance < distance_thresh) && (angle < angle_thresh))\n    {\n      gl_Position = vec4(2.0 * img_coords / dim - 1.0f, 1.0f); // measurement integrated: no need to generate surfel.\n      float confidence = old_confidence + new_confidence;\n      // always update confidence and timestamp:\n      vs_out.normal_confidence.w = confidence;\n      vs_out.timestamp = timestamp;\n      float avg_radius = min(new_radius, old_radius);\n      avg_radius = max(avg_radius, min_radius);\n      vs_out.position_radius.w = avg_radius;\n      vs_out.valid = true;\n\n      vs_out.color_weight_count.x = pack(vec3(0.0, 0.7, 0.0f)); // green\n      vs_out.color_weight_count.z = creation_timestamp;\n\n      float r = (depth - min_depth) / (max_depth - min_depth);\n      float a = angle;\n      float d = distance;\n\n      float p = p_stable;\n\n      if(confidence_mode == 1 || confidence_mode == 3) p *= exp(-a*a / (sigma_angle*sigma_angle));\n      if(confidence_mode == 2 || confidence_mode == 3) p *= exp(-d*d / (sigma_distance*sigma_distance));\n\n      p = clamp(p, p_unstable, 1.0);\n\n      update_confidence = log(p / (1.0 - p));\n\n      if((new_radius < old_radius && timestamp - creation_timestamp < active_timestamps) || update_always)\n      {\n        float w1 = 0.9;\n        float w2 = 0.1;\n\n        if(weighting_scheme > 0)\n        {\n          w1 = old_weight;\n          w2 = 1;\n          if(weighting_scheme == 2) w2 = dot(n, view_dir);\n          vs_out.color_weight_count.y = min(max_weight, w1 + w2);\n\n          float sum = w1 + w2;\n          w1 /= sum;\n          w2 /= sum;\n        }\n\n\n        vec3 avg_position = w1 * old_position.xyz + w2 * v_global.xyz;\n        // vec3 avg_normal = normalize(w1 * old_normal.xyz + w2 * n_global.xyz);\n        vec3 avg_normal = slerp(old_normal.xyz, n_global.xyz, w1);\n\n        // update semantic probability\n        float avg_prob = 0;\n        if(round(data_label) != round(model_label))\n          avg_prob = w1 * model_prob + w2 * (1 - data_prob);\n        else\n          avg_prob = w1 * model_prob + w2 * data_prob;\n        vs_out.semantic_map.w = avg_prob;\n\n        // re-center the vertex such that it should cover the pixel again completely.\n        // vec3 v_s =  (inv_pose * vec4(avg_position,1.0)).xyz;\n        // vec3 n_s =  (inv_pose * vec4(avg_normal,0.0)).xyz;\n\n        // vec4 cpos = centerize(img_coords.xy, v_s, n_s, textureSize(vertex_map));\n        // avg_position = (pose * cpos).xyz;\n        // avg_position = centerize(img_coords.xy, avg_position, avg_normal, textureSize(vertex_map));\n\n        if(averaging_scheme == 1)\n        {\n          // move surfel along the normal towards measurment.\n          avg_position = old_position.xyz + w2 * distance * old_normal.xyz;\n          avg_normal = slerp(old_normal.xyz, n_global.xyz, w1);\n        }\n\n        avg_normal = normalize(avg_normal);\n        avg_position = (surfelPose_inv * vec4(avg_position.xyz, 1)).xyz;\n        avg_normal = (surfelPose_inv * vec4(avg_normal.xyz, 0)).xyz;\n\n        vs_out.position_radius = vec4(avg_position.xyz, avg_radius);\n        vs_out.normal_confidence = vec4(avg_normal.xyz, confidence);\n\n        vs_out.color_weight_count.x = pack(vec3(1.0, 0.0, 1.0f)); // magenta: measurement integrated.\n      }\n    }\n    else\n    {\n      int idx = int(texture(index_map, img_coords.xy)) - 1;\n      if(idx == gl_VertexID) // ensure that surfel is closest visible surfel.\n      {\n        // if not matching; reduce confidence...\n        update_confidence = log(p_unstable/(1.0 - p_unstable));\n        vs_out.color_weight_count.x = pack(vec3(0.0, 1.0, 1.0f));\n      }\n    }\n  }\n  else if(visible && inside && false)\n  {\n    update_confidence = log_unstable;\n    vs_out.color_weight_count.x = pack(vec3(1.0, 0.0, 0.0f));\n\n    // we have a visible surfel without associated measurment => adjust radius to cover pixel\n    int idx = int(texture(index_map, img_coords.xy)) - 1;\n    if(idx == gl_VertexID && img_coords.y > 10) // ensure that surfel is closest visible surfel.\n    {\n      //vs_out.position_radius.w = min(old_radius, get_radius(vertex, normal, pixel_size));\n    }\n  }\n\n  update_confidence = update_confidence - penalty;\n\n  // static state bayes filter (see Thrun et al., Probabilistic Robotics, p. 286):\n  if(use_stability)\n    vs_out.normal_confidence.w = min(old_confidence + update_confidence - log_prior, upper_stability_bound);\n  else\n    vs_out.normal_confidence.w = old_confidence;\n\n  if(vs_out.normal_confidence.w < log_unstable && use_stability) vs_out.valid = false;\n\n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/update_surfels.geom", "#version 330 core\n\n/**\n *  \author behley\n *\n *  \author Xieyuanli Chen\n **/\n\nlayout(points) in;\nlayout(points, max_vertices = 1) out;\n\nout float prior_new;\n\nin SURFEL\n{\n  bool valid;\n  vec4 position_radius;\n  vec4 normal_confidence;\n  int timestamp;\n  vec3 color_weight_count;\n  vec4 semantic_map; // for semantic map\n} gs_in[];\n\nout vec4 sfl_position_radius;\nout vec4 sfl_normal_confidence;\nout int sfl_timestamp;\nout vec3 sfl_color_weight_count;\nout vec4 sfl_semantic_map;\n\nvoid main()\n{\n  if(gs_in[0].valid)\n  {\n    gl_Position = gl_in[0].gl_Position;\n    sfl_position_radius = gs_in[0].position_radius;\n    sfl_normal_confidence = gs_in[0].normal_confidence;\n    sfl_timestamp = gs_in[0].timestamp;\n    sfl_color_weight_count =  gs_in[0].color_weight_count;\n    sfl_semantic_map = gs_in[0].semantic_map;\n\n    EmitVertex();\n    EndPrimitive();\n  }\n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/update_surfels.frag", "#version 330 core\n\n/**\n *  \author behley\n **/\n\nlayout (location = 0) out vec4 color;\n\nvoid main()\n{\n  color = vec4(1, 0, 0, 0); // integrated measurement.\n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/extract_surfels.vert", "#version 330 core\n\n/**\n *  \author behley\n *\n *  \author Xieyuanli Chen\n **/\n\nlayout (location = 0) in vec4 position_radius;\nlayout (location = 1) in vec4 normal_confidence;\nlayout (location = 2) in int in_timestamp;\nlayout (location = 3) in vec3 surfel_color_weight_count;\nlayout (location = 4) in vec4 sfl_semantic_map;\n\nuniform samplerBuffer poseBuffer;\nuniform vec2 submap_center;\nuniform float submap_extent;\n\nout SURFEL\n{\n  bool valid;\n  vec4 position_radius;\n  vec4 normal_confidence;\n  int timestamp;\n  vec3 color_weight_count;\n  vec4 semantic_map;\n} vs_out;\n\nmat4 get_pose(int timestamp)\n{\n  int offset = 4 * timestamp;\n  return mat4(texelFetch(poseBuffer, offset), texelFetch(poseBuffer, offset + 1),\n              texelFetch(poseBuffer, offset + 2), texelFetch(poseBuffer, offset+3));\n}\n\nmat4 inverse_pose(mat4 pose)\n{\n  mat3 R = transpose(mat3(pose));\n  vec3 t = vec3(pose[3]);\n  mat4 result = mat4(R);\n  result[3] = vec4(-R*t, 1);\n\n  return result;\n}\n\nvoid main()\n{\n  mat4 surfelPose = get_pose(int(surfel_color_weight_count.z));\n  vec4 position = surfelPose * vec4(position_radius.xyz, 1.0);\n\n  if(abs(position.x - submap_center.x) > submap_extent || abs(position.y - submap_center.y) > submap_extent)\n  {\n    vs_out.valid = false;\n  }\n  else\n  {\n    vs_out.valid = true;\n    vs_out.position_radius = position_radius;\n    vs_out.normal_confidence = normal_confidence;\n    vs_out.timestamp = in_timestamp;\n    vs_out.color_weight_count = surfel_color_weight_count;\n    vs_out.semantic_map = sfl_semantic_map;\n  }\n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/init_radiusConf.vert", "#version 330 core\n\n/**\n *  \author behley\n **/\n\nlayout (location = 0) in vec2 img_coords; // image coords = (x, y) in [0, w] x [0, h]\n\nuniform sampler2DRect vertex_map;\nuniform sampler2DRect normal_map;\n\nuniform float fov_up;\nuniform float fov_down;\nuniform float max_depth;\nuniform float min_depth;\nuniform float pixel_size;\nuniform int confidence_mode;\nuniform float min_radius;\nuniform float max_radius;\nuniform float angle_thresh;\n\n\nconst vec2 halfpix = vec2(0.5f, 0.5f);\nconst float sqrt2 = 1.41421356237f;\nconst float pi = 3.14159265358979323846f;\nconst float inv_pi = 0.31830988618379067154f;\nconst float pi_2 = 1.57079632679;\n\nout float valid;\nout vec4 centerized_vertex;\nout float radius;\nout float confidence;\n\nfloat get_radius(vec4 vertex, vec4 normal, float pixel_size)\n{\n  float d = length(vertex.xyz);\n\n  return  1.41 * d * pixel_size / clamp(dot(normal.xyz, -vertex.xyz / d), 0.5, 1.0);\n}\n\nvoid main()\n{\n  vec2 tex_dim = textureSize(vertex_map);\n  \n  gl_Position = vec4(2.0 * img_coords / tex_dim - vec2(1.0), 0, 1);\n  valid = 0.0;\n  radius = 0.0;\n  confidence = 0.0;\n  \n  vec4 vertex = texture(vertex_map, img_coords);\n  vec4 normal = texture(normal_map, img_coords);\n  vec3 view_dir = -vertex.xyz / length(vertex.xyz);\n  \n  float angle = dot(normal.xyz, view_dir);\n  \n  if(vertex.w > 0.5 && normal.w > 0.5 && angle > angle_thresh)\n  {   \n    valid = 1.0;\n   \n    float angle = 1.0 - clamp(dot(normal.xyz, view_dir), 0, 1);\n    \n    float confidence = 1.0f;\n\n    centerized_vertex = vertex;\n    radius = get_radius(vertex, normal, pixel_size);\n    radius = min(max(radius, min_radius), max_radius);\n  }    \n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/init_radiusConf.frag", "#version 330 core\n\n/**\n *  \author behley\n **/\n\nin float valid;\nin vec4 centerized_vertex;\nin float radius;\nin float confidence;\n\nlayout (location = 0) out vec4 centerized_vertex_map;\nlayout (location = 1) out vec4 radius_confidence_map;\n\n\nvoid main()\n{\n  centerized_vertex_map = centerized_vertex;\n  radius_confidence_map = vec4(radius, confidence, 0, valid);\n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/copy_surfels.vert", "#version 330 core\n\n/**\n *  \author behley\n *\n *  \author Xieyuanli Chen\n **/\n\nlayout (location = 0) in vec4 position_radius;\nlayout (location = 1) in vec4 normal_confidence;\nlayout (location = 2) in int in_timestamp;\nlayout (location = 3) in vec3 surfel_color_weight_count;\nlayout (location = 4) in vec4 sfl_semantic_map;\n\nout SURFEL\n{\n  bool valid;\n  vec4 position_radius;\n  vec4 normal_confidence;\n  int timestamp;\n  vec3 color_weight_count;\n  vec4 semantic_map; // for semantic map\n} vs_out;\n\n// active area\nuniform vec2 submap_center;\nuniform float submap_extent;\n\nuniform samplerBuffer poseBuffer;\n\nmat4 get_pose(int t)\n{\n  int offset = 4 * t;\n  return mat4(texelFetch(poseBuffer, offset), texelFetch(poseBuffer, offset + 1),\n              texelFetch(poseBuffer, offset + 2), texelFetch(poseBuffer, offset+3));\n}\n\nvoid main()\n{\n  mat4 surfelPose = get_pose(int(surfel_color_weight_count.z));\n  vec4 position = surfelPose * vec4(position_radius.xyz, 1.0);\n\n  if(in_timestamp < 0 || abs(position.x - submap_center.x) > submap_extent || abs(position.y - submap_center.y) > submap_extent)\n  {\n    vs_out.valid = false;\n  }\n  else\n  {\n    vs_out.valid = true;\n    vs_out.position_radius = position_radius;\n    vs_out.normal_confidence = normal_confidence;\n    vs_out.timestamp = in_timestamp;\n    vs_out.color_weight_count = surfel_color_weight_count;\n    vs_out.semantic_map = sfl_semantic_map;\n  }\n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/copy_surfels.geom", "#version 330 core\n\n/**\n *  \author behley\n *\n *  \author Xieyuanli Chen\n **/\n\nlayout(points) in;\nlayout(points, max_vertices = 1) out;\n\nin SURFEL\n{\n  bool valid;\n  vec4 position_radius;\n  vec4 normal_confidence;\n  int timestamp;\n  vec3 color_weight_count;\n  vec4 semantic_map;\n} gs_in[];\n\nout vec4 sfl_position_radius;\nout vec4 sfl_normal_confidence;\nout int sfl_timestamp;\nout vec3 sfl_color_weight_count;\nout vec4 sfl_semantic_map;\n\nvoid main()\n{\n  if(gs_in[0].valid)\n  {\n    sfl_position_radius = gs_in[0].position_radius;\n    sfl_normal_confidence = gs_in[0].normal_confidence;\n    sfl_timestamp = gs_in[0].timestamp;\n    sfl_color_weight_count = gs_in[0].color_weight_count;\n    sfl_semantic_map = gs_in[0].semantic_map;\n\n    EmitVertex();\n    EndPrimitive();\n  }\n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/gen_surfels.frag", "#version 330 core\n\n/**\n *  \author behley\n *\n *  \author Xieyuanli Chen\n **/\n\nlayout (location = 0) out vec4 upd_vertex_radius;\nlayout (location = 1) out vec4 upd_normal_confidence;\n\nin vec4 sfl_position_radius;\nin vec4 sfl_normal_confidence;\nin int sfl_timestamp;\n\nvoid main()\n{\n  // store information for update.\n  upd_vertex_radius = sfl_position_radius;\n  upd_normal_confidence = sfl_normal_confidence;\n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/gen_surfels.geom", "#version 400 core\n\n/**\n *  \author behley\n *\n *  \author Xieyuanli Chen\n **/\n\n#include \"shader/color.glsl\"\n\nlayout(points) in;\nlayout(points, max_vertices = 1) out;\n\nuniform int timestamp;\n\nin SURFEL {\n  bool valid;\n  vec2 img_coords;\n} gs_in[];\n\nout vec4 sfl_position_radius;\nout vec4 sfl_normal_confidence;\nout int sfl_timestamp;\nout vec3  sfl_color_weight_count;\nout vec4  sfl_semantic_map;\n\nuniform sampler2DRect vertex_map;\nuniform sampler2DRect normal_map;\nuniform sampler2DRect radiusConfidence_map;\n\nuniform sampler2DRect semantic_map;\nuniform sampler2DRect model_semantic_map;\n// uniform sampler1D prior_map;\n\nuniform float removed_class;\n\nuniform mat4 pose; // current pose of laser scanner.\nuniform mat4 inv_pose; // current pose of laser scanner.\nuniform float log_prior;\n\nuniform float width;\nuniform float height;\nuniform float pixel_size;\n\nuniform float fov_up;\nuniform float fov_down;\nuniform float max_depth;\nuniform float min_depth;\n\nconst float sqrt2 = 1.41421356237f;\nconst float pi = 3.14159265358979323846f;\nconst float inv_pi = 0.31830988618379067154f;\nconst float pi_2 = 1.57079632679;\n\n// semantic color_map\n  vec4 unlabeled = vec4(0, 0, 0, 0);\n  vec4 outlier = vec4(0, 0, 255, 1);\n  vec4 car = vec4(245, 150, 100, 10);\n  vec4 bicycle = vec4(245, 230, 100, 11);\n  vec4 bus = vec4(250, 80, 100, 13);\n  vec4 motorcycle = vec4(150, 60, 30,15);\n  vec4 on_rails = vec4(255, 0, 0, 16);\n  vec4 truck = vec4(180, 30, 80, 18);\n  vec4 other_vehicle = vec4(255, 0, 0, 20);\n  vec4 person = vec4(30, 30, 255, 30);\n  vec4 bicyclist = vec4(200, 40, 255, 31);\n  vec4 motorcyclist = vec4(90, 30, 150, 32);\n  vec4 road = vec4(255, 0, 255, 40);\n  vec4 parking = vec4(255, 150, 255, 44);\n  vec4 sidewalk = vec4(75, 0, 75, 48);\n  vec4 other_ground = vec4(75, 0, 175, 49);\n  vec4 building = vec4(0, 200, 255, 50);\n  vec4 fence = vec4(50, 120, 255, 51);\n  vec4 other_structure = vec4(0, 150, 255, 52);\n  vec4 lane_marking = vec4(170, 255, 150, 60);\n  vec4 vegetation = vec4(0, 175, 0, 70);\n  vec4 trunk = vec4(0, 60, 135, 71);\n  vec4 terrain = vec4(80, 240, 150, 72);\n  vec4 pole = vec4(150, 240, 255, 80);\n  vec4 traffic_sign = vec4(0, 0, 255, 81);\n  vec4 other_object = vec4(255, 255, 50, 99);\n  vec4 moving_car = vec4(245, 150, 100, 252);\n  vec4 moving_bicyclist = vec4(255, 0, 0, 256);\n  vec4 moving_person = vec4(200, 40, 255, 253);\n  vec4 moving_motorcyclist = vec4(30, 30, 255, 254);\n  vec4 moving_on_rails = vec4(90, 30, 150, 255);\n  vec4 moving_bus = vec4(250, 80, 100, 257);\n  vec4 moving_truck = vec4(180, 30, 80, 258);\n  vec4 moving_other_vehicle = vec4(255, 0, 0, 259);\n\nvec3 projectSpherical(vec3 position)\n{\n  float fov = abs(fov_up) + abs(fov_down);\n  float depth = length(position.xyz);\n  float yaw = atan(position.y, position.x);\n  float pitch = -asin(position.z / depth);\n\n  float x = 0.5 * ((-yaw * inv_pi) + 1.0); // in [0, 1]\n  float y = (1.0 - (degrees(pitch) + fov_up) / fov); // in [0, 1]\n  float z = (depth - min_depth) / (max_depth - min_depth); // in [0, 1]\n\n  // half-pixel coordinates.\n  x = (floor(x * width) + 0.5);\n  y = (floor(y * height) + 0.5);\n\n  return vec3(x, y, z);\n}\n\nvoid main()\n{\n  if(gs_in[0].valid)\n  {\n    vec2 img_coords = gs_in[0].img_coords;\n\n    vec4 v = vec4(texture(vertex_map, img_coords).xyz, 1.0);\n    vec4 n = vec4(texture(normal_map, img_coords).xyz, 0.0);\n    vec4 v_global = v;\n    vec4 n_global = normalize(n);\n    float radius = texture(radiusConfidence_map, img_coords).x;\n\n    float weight = 1.0f;\n\n    // all surfels are outputed to the transform feedback buffer.\n    sfl_position_radius = vec4(v_global.xyz, radius);\n    sfl_normal_confidence = vec4(n_global.xyz, log_prior);\n    sfl_timestamp = timestamp;\n    sfl_color_weight_count = vec3(pack(vec3(0,0,1)), weight, timestamp);\n\n    // detect and remove outliers\n    sfl_semantic_map = texture(semantic_map, gs_in[0].img_coords);\n    float semantic_label = sfl_semantic_map.x * 255.0;\n    float model_label = texture(model_semantic_map, img_coords.xy).x * 255.0;\n\n    // only dealing with movable objects\n    if(semantic_label == car.w || semantic_label == bicycle.w ||\n      semantic_label == bus.w || semantic_label == motorcycle.w||\n      semantic_label == truck.w|| semantic_label == other_vehicle.w||\n      semantic_label == person.w|| semantic_label == bicyclist.w ||\n      semantic_label == motorcyclist.w)\n      sfl_normal_confidence = vec4(n_global.xyz, log_prior - 0.5);\n\n    EmitVertex();\n    EndPrimitive();\n  }\n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/gen_surfels.vert", "#version 330 core\n\n/**\n *  \author behley\n *\n *  \author Xieyuanli Chen\n **/\n\n#include \"shader/color.glsl\"\n\nlayout (location = 0) in vec2 img_coords; // image coords = (x, y) in [0, w] x [0, h]\n\n// centerized vertex map, normal map and precomputed radius/confidence map.\nuniform sampler2DRect vertex_map;\nuniform sampler2DRect normal_map;\nuniform sampler2DRect measurementIntegrated_map;\nuniform sampler2DRect radiusConfidence_map;\n\nuniform int timestamp;\nuniform mat4 pose; // current pose of laser scanner.\nuniform float log_prior;\n\nuniform float width;\nuniform float height;\nuniform float pixel_size;\n\nuniform float fov_up;\nuniform float fov_down;\nuniform float max_depth;\nuniform float min_depth;\n\n\nout SURFEL {\n  bool valid;\n  vec2 img_coords;\n} vs_out;\n\nvoid main()\n{\n  vec3 vertex = texture(vertex_map, img_coords).xyz;\n  vec3 normal = texture(normal_map, img_coords).xyz;\n\n  bool invalid = (texture(vertex_map, img_coords).w < 1.0f) || (texture(normal_map, img_coords).w < 1.0f);\n  invalid = invalid || (texture(radiusConfidence_map, img_coords).w < 0.5f);\n  bool integrated = texture(measurementIntegrated_map, img_coords).x > 0.5;\n\n  vec3 view_dir = -vertex / length(vertex);\n\n  // vertex/normal invalid or already integrated or normal pointing in the wrong direction.\n  vs_out.valid = (!invalid && !integrated && (dot(normal, view_dir) > 0.01));\n  vs_out.img_coords = img_coords;\n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/init_depthimg.frag", "#version 330 core\n\n/**\n *  \author behley\n **/\n\nflat in vec2 depth_index;\nflat in vec3 vertex_coord;\n\nlayout (location = 0) out float depth;  // depth image.\nlayout (location = 1) out int index;    // index map.\nlayout (location = 2) out vec3 vertex;  // vertex map.\nlayout (location = 3) out int valid; // validity map.\n\nvoid main()\n{\n    depth = -1.0;\n    index = -1;\n    vertex = vec3(1./0.);\n    valid = 0;\n} \n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/avg_vertexmap.frag", "#version 330 core\n/**\n *  \author behley\n **/\n\nin vec2 texCoords;\n\nuniform sampler2DRect in_vertexmap;\n\nout vec4 out_vertexmap;\n\nvoid main()\n{\n  vec2 dim = textureSize(in_vertexmap);\n  vec2 p = vec2(int(texCoords.x * dim.x), int(texCoords.y * dim.y));\n  \n  out_vertexmap = texture(in_vertexmap, p);\n  if(out_vertexmap.w > 0.5) out_vertexmap = out_vertexmap / out_vertexmap.w;\n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/gen_depthimg.vert", "#version 330 core\n\n/**\n *  \author behley\n **/\n\nlayout (location = 0) in vec4 position; // x, y, z, 1\n\nflat out vec2 depth_index; // depth, index of point.\nflat out vec4 image_coord; // float pixel coords x, y, depth.\nflat out vec4 vertex_coord; // coordinate of the vertex producing this pixel.\nflat out vec4 ndc_coord;\n\nconst float pi = 3.14159265358979323846f;\nconst float inv_pi = 0.31830988618379067154f;\nconst float pi_2 = 1.57079632679;\n\n// Velodyne HDL-64E: 26.8 vertical fov (+2 <-> -24.8)\nuniform float fov_up;\nuniform float fov_down;\n\n// params: min_depth, max_depth?\nuniform bool perform_rounding;\nuniform int width;\nuniform int height;\n\nuniform float min_depth;\nuniform float max_depth;\n\nvoid main()\n{ \n  float fov = abs(fov_up) + abs(fov_down);\n  float depth = length(position.xyz);\n  float yaw = atan(position.y, position.x);\n  float pitch = -asin(position.z / depth); // angle = acos((0,0,1) * p/||p||) - pi/2 = pi/2 - asin(x) + pi/2 \n  \n  float x = (-yaw * inv_pi); // in [-1, 1]\n  float y = (1.0 - 2.0 * (degrees(pitch) + fov_up) / fov); // in [-1, 1]\n  float z = 2.0f * ((depth - min_depth) / (max_depth - min_depth)) - 1.0f; // in [-1, 1]\n  \n  float x_img = 0.5 * ((-yaw * inv_pi) + 1.0); // in [0, 1]\n  float y_img = (1.0 - ((degrees(pitch) + fov_up) / fov)); // in [0, 1]\n  \n  // force that each point lies exactly inside the texel enabling reproducible results.\n  x = 2.0f * ((floor(0.5f * (x + 1.0f) * width ) + 0.5f ) / width) - 1.0;\n  y = 2.0f * ((floor(0.5f * (y + 1.0f) * height ) + 0.5f ) / height) - 1.0;\n \n  \n  gl_Position = vec4(x, y, z, 1.0);\n  \n  depth_index = vec2(depth, gl_VertexID);\n  ndc_coord = vec4(x, y, z, 1.0f);\n  image_coord = vec4(x_img, y_img, 0, 1.0f);\n  vertex_coord = vec4(position.xyz, 1.0);\n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/gen_depthimg.frag", "#version 330 core\n\n/**\n *  \author behley\n **/\n\nflat in vec2 depth_index;\nflat in vec4 vertex_coord;\nflat in vec4 image_coord;\n\nlayout (location = 0) out float color;  // depth image.\nlayout (location = 1) out int index;    // index map.\nlayout (location = 2) out vec4 vertex;  // vertex map.\nlayout (location = 3) out int valid;  // validity map.\nlayout (location = 4) out vec4 out_img_coord; // image coordinates\n\nvoid main()\n{\n    color = depth_index.x;\n    index = int(depth_index.y);\n    vertex = vertex_coord;\n    valid = 1;\n    out_img_coord = image_coord;\n} \n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/gen_normalmap.frag", "#version 330\n\n/**\n *  \author behley\n *\n *  \author Xieyuanli Chen\n **/\n\nin vec2 texCoords;\n\nuniform int width;\nuniform int height;\n\nuniform sampler2DRect vertex_map;\nuniform sampler2DRect semantic_map;\n\nlayout (location = 0) out vec4 normal;\nlayout (location = 1) out vec4 eroded_semantic_map;\n\nuniform int normal_radius;\n\n#include \"shader/color_map.glsl\"\n\nfloat wrap(float x, float dim)\n{\n  float value = x;\n\n  while(value >= dim) value = (value - dim);\n  while(value < 0) value = (value + dim);\n\n  return value;\n}\n\nbool valid(vec4 normal)\n{\n  return (normal.w > 0.5);\n}\n\nvec4 invalid = vec4(0.0, 0.0, 0.0, 1.0);\n\nvoid main()\n{\n  float width = textureSize(vertex_map).x;\n  vec2 pos = texCoords * textureSize(vertex_map);\n  normal = invalid;\n  eroded_semantic_map = invalid; // for invalid points\n\n  if(texture(vertex_map, pos).w > 0.0f)\n  {\n    normal.w = 1.0f;\n\n    vec4 p = texture(vertex_map, pos);\n    vec4 u = texture(vertex_map, vec2(wrap(pos.x + 1, width), pos.y));\n    vec4 v = texture(vertex_map, vec2(pos.x, pos.y + 1));\n    vec4 s = texture(vertex_map, vec2(wrap(pos.x - 1, width), pos.y));\n    vec4 t = texture(vertex_map, vec2(pos.x, pos.y - 1));\n\n    u.xyz = normalize(u.xyz - p.xyz);\n    v.xyz = normalize(v.xyz - p.xyz);\n    s.xyz = normalize(p.xyz - s.xyz);\n    t.xyz = normalize(p.xyz - t.xyz);\n\n    if(u.w < 1.0f && v.w < 1.0f) normal.w = 0;\n    if(s.w < 1.0f && t.w < 1.0f) normal.w = 0;\n\n    if(!valid(u) || !valid(v)) normal.w = 0;\n\n    // floodfill erosion\n    int kernel_size = 2;\n    eroded_semantic_map = texture(semantic_map, pos);\n\n    for(int offset = 1; offset < kernel_size; offset++)\n    {\n      float p_label = texture(semantic_map, pos).x;\n      float u_label = texture(semantic_map, vec2(wrap(pos.x + offset, width), pos.y)).x;\n      float v_label = texture(semantic_map, vec2(pos.x, pos.y + offset)).x;\n      float s_label = texture(semantic_map, vec2(wrap(pos.x - offset, width), pos.y)).x;\n      float t_label = texture(semantic_map, vec2(pos.x, pos.y - offset)).x;\n\n      if((p_label != u_label && u_label != 0.0) ||\n         (p_label != v_label && v_label != 0.0) ||\n         (p_label != s_label && s_label != 0.0) ||\n         (p_label != t_label && t_label != 0.0))\n        eroded_semantic_map = invalid;\n    }\n\n    // TODO: check if distances in x/y-direction are similar.\n    //if(abs(length(u) - length(s)) / max(length(u), length(s)) > 0.5) normal.w = 0;\n    //if(abs(length(v) - length(t)) / max(length(t), length(v)) > 0.5) normal.w = 0;\n\n    if(normal.w > 0.0f)\n    {\n      vec3 w = cross(u.xyz, v.xyz);\n      float len = length(w);\n      normal = vec4(w / len, 1.0);\n      normal.w = int(len > 0.0000001);\n    }\n  }\n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/gen_indexmap.vert", "#version 330 core\n\n/**\n *  \author behley\n *\n *  \author Xieyuanli Chen\n **/\n\nlayout (location = 0) in vec4 surfel_position_radius;\nlayout (location = 1) in vec4 surfel_normal_confidence;\nlayout (location = 2) in int  surfel_timestamp;\nlayout (location = 3) in vec3 surfel_color_weight_count;\nlayout (location = 4) in vec4 sfl_semantic_map;\n\nflat out float index;\nout vec4 vertex;\nout vec4 normal;\n\nconst vec2 halfpix = vec2(0.5f, 0.5f);\nconst float sqrt2 = 1.41421356237f;\nconst float pi = 3.14159265358979323846f;\nconst float inv_pi = 0.31830988618379067154f;\nconst float pi_2 = 1.57079632679;\n\nuniform mat4 pose;\nuniform mat4 inv_pose;\n\nuniform float fov_up;\nuniform float fov_down;\nuniform float max_depth;\nuniform float min_depth;\nuniform float width;\nuniform float height;\n\nuniform samplerBuffer poseBuffer;\n\nvec3 projectSpherical(vec4 position)\n{\n  float fov = abs(fov_up) + abs(fov_down);\n  float depth = length(position.xyz);\n  float yaw = atan(position.y, position.x);\n  float pitch = -asin(position.z / depth);\n\n  float x = 0.5 * ((-yaw * inv_pi) + 1.0); // in [0, 1]\n  float y = (1.0 - (degrees(pitch) + fov_up) / fov); // in [0, 1]\n  float z = (depth - min_depth) / (max_depth - min_depth); // in [0, 1]\n\n  x = (floor(x * width) + 0.5) / width;\n  y = (floor(y * height) + 0.5) / height;\n\n  return vec3(x, y, z);\n}\n\nmat4 get_pose(int timestamp)\n{\n  int offset = 4 * timestamp;\n  return mat4(texelFetch(poseBuffer, offset), texelFetch(poseBuffer, offset + 1),\n              texelFetch(poseBuffer, offset + 2), texelFetch(poseBuffer, offset+3));\n}\n\n/** \brief depth-buffered index map.  **/\nvoid main()\n{\n\n  mat4 surfelPose = get_pose(int(surfel_color_weight_count.z));\n\n  vertex = inv_pose * surfelPose * vec4(surfel_position_radius.xyz, 1.0);\n  normal = inv_pose * surfelPose * vec4(surfel_normal_confidence.xyz, 0.0);\n\n  vec4 p = vertex;\n  vec4 n = normal;\n\n  gl_Position = vec4(-10.0);\n\n  // visible from current position.\n  if(dot(n.xyz, -p.xyz/length(p.xyz)) > 0.01)\n  {\n    gl_Position = vec4(2.0 * projectSpherical(p) - vec3(1.0), 1.0);\n    index = gl_VertexID + 1; // initially all index pixels are 0.\n  }\n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/gen_indexmap.frag", "#version 330 core\n\n/**\n *  \author behley\n **/\n\nflat in float index;\nin vec4 vertex;\nin vec4 normal;\n\nlayout (location = 0) out float indexmap;\nlayout (location = 1) out vec4 vertexmap;\nlayout (location = 2) out vec4 normalmap;\n\nvoid main()\n{\n  indexmap = index;\n  vertexmap = vertex;\n  normalmap = normal;\n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/bilateral_filter.frag", "#version 330 core\n\n/**\n *  \author behley\n **/\n\nin vec2 texCoords;\n\nuniform sampler2DRect in_vertexmap;\nuniform float width;\nuniform float height;\nuniform float sigma_space;\nuniform float sigma_range;\n\nout vec4 out_vertexmap;\n\nfloat wrap(float x, float dim)\n{\n  float value = x;\n  \n  while(value >= dim) value = (value - dim);\n  while(value < 0) value = (value + dim);\n  \n  return value;\n}\n\nvoid main()\n{\n  int x = int(texCoords.x * width);\n  int y = int(texCoords.y * height);\n\n  vec4 vertex = texture(in_vertexmap, vec2(x, y));\n  \n  out_vertexmap = vertex;\n  \n  if(vertex.w > 0.5)\n  {\n    float range = length(vertex.xyz);\n    vec3 ray = vertex.xyz / range;\n    \n  \n    float sigma_space_factor = -0.5 / (sigma_space * sigma_space); // elastic fusion: 0.024691358 => sigma = 4.5\n    float sigma_range_factor = -0.5 / (sigma_range * sigma_range); // elastic fusion: 0.000555556 => sigma = 30\n          \n    const int R = 6; // make R dependent on sigma_space?\n    const int D = R * 2 + 1;\n      \n    int tx = x - D / 2 + D;\n    int ty = min(y - D / 2 + D, int(height));\n  \n    float sum1 = 0.0f;\n    float sum2 = 0.0f;\n      \n    for(int cy = max(y - D / 2, 0); cy < ty; ++cy)\n    {\n        for(int cx = x - D / 2; cx < tx; ++cx)\n        { \n          float xx = wrap(cx, width);\n        \n          vec4 tmp = texture(in_vertexmap, vec2(xx, cy));\n          if(tmp.w < 0.5) continue;\n          \n          float tmp_range = length(tmp);\n          \n          \n          float diff_space2 = (x-xx) * (x-xx) + (y-cy) * (y-cy); // dot((vertex.xyz - tmp.xyz) , (vertex.xyz - tmp.xyz));\n          float diff_range2 = (range - tmp_range) * (range - tmp_range);\n\n          float weight = exp(diff_space2 * sigma_space_factor + diff_range2 * sigma_range_factor);\n\n          sum1 += tmp_range * weight;\n          sum2 += weight;\n        }\n    }\n    \n    float filtered_range = sum1 / sum2; \n    \n    out_vertexmap = vec4( filtered_range * ray, 1.0);\n  }\n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/gen_vertexmap.vert", "#version 330 core\n#pragma glsl\n\n/**\n *  \author behley\n *\n *  \author Xieyuanli Chen\n **/\n\nlayout (location = 0) in vec4 position; // x, y, z, 1\nlayout (location = 1) in float label; // x\nlayout (location = 2) in float prob; // x\n\nout vec4 vertex_coord; // coordinate of the vertex producing this pixel.\nout float vert_label;\nout float vert_label_prob;\n\nconst float pi = 3.14159265358979323846f;\nconst float inv_pi = 0.31830988618379067154f;\nconst float pi_2 = 1.57079632679;\n\nuniform float width;\nuniform float height;\nuniform float fov_up;\nuniform float fov_down;\nuniform float min_depth;\nuniform float max_depth;\nuniform float removed_class;\n\nuniform mat4 Tr;\nuniform mat4 Tr_inv;\nuniform mat4 P2;\n\nconst vec4 invalid = vec4(0.0, 0.0, 0.0, 0.0);\nuniform bool isfirst;\n\n// semantic color map (B, G, R, label)\n  vec4 unlabeled = vec4(0, 0, 0, 0);\n  vec4 outlier = vec4(0, 0, 255, 1);\n  vec4 car = vec4(245, 150, 100, 10);\n  vec4 bicycle = vec4(245, 230, 100, 11);\n  vec4 bus = vec4(250, 80, 100, 13);\n  vec4 motorcycle = vec4(150, 60, 30,15);\n  vec4 on_rails = vec4(255, 0, 0, 16);\n  vec4 truck = vec4(180, 30, 80, 18);\n  vec4 other_vehicle = vec4(255, 0, 0, 20);\n  vec4 person = vec4(30, 30, 255, 30);\n  vec4 bicyclist = vec4(200, 40, 255, 31);\n  vec4 motorcyclist = vec4(90, 30, 150, 32);\n  vec4 road = vec4(255, 0, 255, 40);\n  vec4 parking = vec4(255, 150, 255, 44);\n  vec4 sidewalk = vec4(75, 0, 75, 48);\n  vec4 other_ground = vec4(75, 0, 175, 49);\n  vec4 building = vec4(0, 200, 255, 50);\n  vec4 fence = vec4(50, 120, 255, 51);\n  vec4 other_structure = vec4(0, 150, 255, 52);\n  vec4 lane_marking = vec4(170, 255, 150, 60);\n  vec4 vegetation = vec4(0, 175, 0, 70);\n  vec4 trunk = vec4(0, 60, 135, 71);\n  vec4 terrain = vec4(80, 240, 150, 72);\n  vec4 pole = vec4(150, 240, 255, 80);\n  vec4 traffic_sign = vec4(0, 0, 255, 81);\n  vec4 other_object = vec4(255, 255, 50, 99);\n  vec4 moving_car = vec4(245, 150, 100, 252);\n  vec4 moving_bicyclist = vec4(255, 0, 0, 256);\n  vec4 moving_person = vec4(200, 40, 255, 253);\n  vec4 moving_motorcyclist = vec4(30, 30, 255, 254);\n  vec4 moving_on_rails = vec4(90, 30, 150, 255);\n  vec4 moving_bus = vec4(250, 80, 100, 257);\n  vec4 moving_truck = vec4(180, 30, 80, 258);\n  vec4 moving_other_vehicle = vec4(255, 0, 0, 259);\n\nvoid main()\n{\n  vert_label = label;\n  vert_label_prob = prob;\n\n  float fov = abs(fov_up) + abs(fov_down);\n  float depth = length(position.xyz);\n  float yaw = atan(position.y, position.x);\n  float pitch = -asin(position.z / depth); // angle = acos((0,0,1) * p/||p||) - pi/2 = pi/2 - asin(x) + pi/2\n\n  float x = (-yaw * inv_pi); // in [-1, 1]\n  float y = (1.0 - 2.0 * (degrees(pitch) + fov_up) / fov); // in [-1, 1]\n  float z = 2.0f * ((depth - min_depth) / (max_depth - min_depth)) - 1.0f; // in [-1, 1]\n\n  // force that each point lies exactly inside the texel enabling reproducible results.\n  x = 2.0f * ((floor(0.5f * (x + 1.0f) * width ) + 0.5f ) / width) - 1.0;\n  y = 2.0f * ((floor(0.5f * (y + 1.0f) * height ) + 0.5f ) / height) - 1.0;\n\n  gl_Position = vec4(x, y, z, 1.0);\n  vertex_coord = vec4(position.xyz, 1.0);\n\n  // remove all movable objects during initialization period\n  if(isfirst){\n    if(vert_label == car.w || vert_label == bicycle.w ||\n      vert_label == bus.w || vert_label == motorcycle.w||\n      vert_label == truck.w|| vert_label == other_vehicle.w||\n      vert_label == person.w||\n      vert_label == bicyclist.w || vert_label == motorcyclist.w)\n      vertex_coord = invalid;\n  }\n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/gen_vertexmap.frag", "#version 330 core\n\n/**\n *  \author behley\n *\n *  \author Xieyuanli Chen\n **/\n\nin vec4 vertex_coord;\nin float vert_label;\nin float vert_label_prob;\n\nlayout (location = 0) out vec4 color;\nlayout (location = 1) out vec4 semantic_map;\n\nvoid main()\n{\n  color = vertex_coord;\n\n  float vert_label_ = vert_label / 255.0f;\n\n  semantic_map = vec4(vert_label_, vert_label_, vert_label_, vert_label_prob);\n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/gen_semanticmap.frag", "#version 330\n\n/**\n *  \author Xieyuanli Chen\n **/\n\nin vec2 texCoords;\n\nuniform sampler2DRect color_mask;\n\nlayout (location = 0) out vec4 semantic_map;\n\nconst vec4 invalid = vec4(0.0, 0.0, 0.0f, 1.0f);\n\nvoid main()\n{\n  semantic_map = texture(color_mask, vec2(texCoords.x, 1.0 - texCoords.y) * textureSize(color_mask));\n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/floodfill.frag", "#version 330\n\n/**\n *  \author Xieyuanli Chen\n **/\n\nin vec2 texCoords;\n\nuniform int width;\nuniform int height;\n\nuniform sampler2DRect vertex_map;\nuniform sampler2DRect semantic_map;\n\nlayout (location = 0) out vec4 refined_semantic_map;\n\nfloat wrap(float x, float dim)\n{\n  float value = x;\n\n  while(value >= dim) value = (value - dim);\n  while(value < 0) value = (value + dim);\n\n  return value;\n}\n\nbool valid(vec4 normal)\n{\n  return (normal.w > 0.5);\n}\n\nvec4 invalid = vec4(0.0, 0.0, 0.0, 1.0);\n\nvoid main()\n{\n  float width = textureSize(semantic_map).x;\n  vec2 pos = texCoords * textureSize(semantic_map);\n  refined_semantic_map = texture(semantic_map, pos);\n\n  int kernel_size = 3;\n\n  // floodfill\n  {\n    for(int offset = 1; offset < kernel_size; offset++)\n    {\n      vec4 p = texture(vertex_map, pos);\n      vec4 u = texture(vertex_map, vec2(wrap(pos.x + offset, width), pos.y));\n      vec4 v = texture(vertex_map, vec2(pos.x, pos.y + offset));\n      vec4 s = texture(vertex_map, vec2(wrap(pos.x - offset, width), pos.y));\n      vec4 t = texture(vertex_map, vec2(pos.x, pos.y - offset));\n\n      vec4 p_label = texture(semantic_map, pos);\n      vec4 u_label = texture(semantic_map, vec2(wrap(pos.x + offset, width), pos.y));\n      vec4 v_label = texture(semantic_map, vec2(pos.x, pos.y + offset));\n      vec4 s_label = texture(semantic_map, vec2(wrap(pos.x - offset, width), pos.y));\n      vec4 t_label = texture(semantic_map, vec2(pos.x, pos.y - offset));\n\n      float threshold = 0.007;\n\n      // use reciprocal decay\n\n      if(p_label.x == 0.0 && u_label.x != 0 && abs(length(p.xyz) - length(u.xyz)) < threshold * length(p.xyz))\n      {\n        refined_semantic_map = vec4(u_label.xyz, u_label.w / (offset + 1));\n        break;\n      }\n      else if(p_label.x == 0.0 && v_label.x != 0 && abs(length(p.xyz) - length(v.xyz)) < threshold * length(p.xyz))\n      {\n        refined_semantic_map = vec4(v_label.xyz, v_label.w / (offset + 1));\n        break;\n      }\n      else if(p_label.x == 0.0 && s_label.x != 0 && abs(length(p.xyz) - length(s.xyz)) < threshold * length(p.xyz))\n      {\n        refined_semantic_map = vec4(s_label.xyz, s_label.w / (offset + 1));\n        break;\n      }\n      else if(p_label.x == 0.0 && t_label.x != 0 && abs(length(p.xyz) - length(t.xyz)) < threshold * length(p.xyz))\n      {\n        refined_semantic_map = vec4(t_label.xyz, t_label.w / (offset + 1));\n        break;\n      }\n    }\n  }\n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/draw_surfels.frag", "#version 330 core\n\n/**\n *  \author behley\n **/\n\nuniform int surfelDrawMethod; // 0 - texCoord-based fragement discard, 2 - hexagon based.\n\nin vec2 texCoords;\nin vec4 gs_color;\nout vec4 color;\nin float radius;\n\n// phong shading?\n\nvoid main()\n{\n\n  if (gs_color.w < 0.5) discard;\n\n  if(surfelDrawMethod == 0)\n  {\n    if(dot(texCoords, texCoords) > 1.0f) discard;\n    color = gs_color;\n  }\n  else\n  {\n    color = gs_color;\n  }\n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/draw_surfels.geom", "#version 330 core\n\n/**\n *  \author behley\n *\n *  \author Xieyuanli Chen\n **/\n\nlayout(points) in;\nlayout(triangle_strip, max_vertices = 6) out;\n\nin SURFEL\n{\n  float radius;\n  vec4 normal;\n  float confidence;\n  int timestamp;\n  vec3 color;\n  vec4 semantic_map; // for semantic map\n} gs_in[];\n\n\nstruct Light\n{\n  vec4 position; // directional lights have w == 0.\n\n  vec3 ambient;\n  vec3 diffuse;\n  vec3 specular;\n};\n\nuniform int num_lights;\nuniform Light lights[10];\n\nstruct Material\n{\n  vec3 ambient;\n  vec3 diffuse;\n  vec3 specular;\n  vec3 emission;\n\n  float shininess;\n  float alpha;\n};\n\nuniform Material material;\n\nuniform mat4 mvp;\nuniform mat4 mvp_inv_t;\nuniform int surfelDrawMethod; // 0 - texCoord-based fragement discard, 2 - hexagon based.\nuniform int colorMode; // 0 - phong, 1 - normal shading, 2 - normal color, 3 - confidence\nuniform float conf_threshold;\n\nuniform vec3 view_pos;\nuniform bool drawCurrentSurfelsOnly;\nuniform int timestamp;\nuniform bool backface_culling;\nuniform bool use_stability;\n\nuniform sampler1D color_map;\n\nout vec4 gs_color;\nout vec2 texCoords;\nout float radius;\n\nconst vec4 rviridis = vec4(2.90912735, -2.14404531, 0.04439198,  0.29390206);\nconst vec4 gviridis = vec4(-0.17293242, -0.16906214,  1.24131122,  0.01871256);\nconst vec4 bviridis = vec4(0.17848859, -1.72405244,  1.23042564,  0.34479632);\n\n// approximate version of viridis colormap.\nvec3 viridis(float t)\n{\n  vec4 tt = vec4(t*t*t, t*t, t, 1.0);\n  return vec3(dot(tt, rviridis), dot(tt, gviridis), dot(tt, bviridis));\n}\n\nvoid main()\n{\n  vec4 p = gl_in[0].gl_Position;\n  vec4 n = gs_in[0].normal;\n  radius = gs_in[0].radius;\n  vec4 u = normalize(vec4(n.y - n.z, -n.x, n.x, 0.0f));\n  vec4 v = vec4(normalize(cross(n.xyz, u.xyz)), 0.0f);\n\n  float c = gs_in[0].confidence;\n  bool valid = (c > conf_threshold || !use_stability);\n  vec3 view_dir = normalize((view_pos.xyz - p.xyz));\n\n  if(colorMode == 1)\n  {\n   gs_color = vec4((vec3(.5f, .5f, .5f) * abs(dot(n.xyz, vec3(1.0, 1.0, 1.0)))) + vec3(0.1f, 0.1f, 0.1f), 1.0f);\n  }\n  else if(colorMode == 2)\n  {\n    gs_color = vec4(abs(n.xyz), 1.0f);\n  }\n  else if(colorMode == 3)\n  {\n    valid = true;\n    gs_color = vec4(viridis(1.0-1.0/(1.0 + exp(c))), 1.0);\n  }\n  else if(colorMode == 5)\n  {\n    vec4 semantic_label = vec4(texture(color_map, gs_in[0].semantic_map.x * 255.0f / 259.0f).rgb, 1.0);\n    if (gs_in[0].semantic_map.x != 0) gs_color = semantic_label;\n    else valid = false;\n  }\n  else\n  {\n    vec3 norm = normalize(vec3(n));\n\n\n    vec3 result = vec3(0);\n\n    vec3 surfel_color = material.diffuse;\n    float alpha = material.alpha;\n\n    if (colorMode == 4)\n    {\n      surfel_color = gs_in[0].color;\n      valid = true;\n      alpha =  1.0 - clamp(conf_threshold - c, 0.1, 1);\n      radius /= sqrt(2);\n    }\n\n\n\n    for(int i = 0; i < num_lights; ++i)\n    {\n      // ambient:\n      vec3 ambient = lights[i].ambient * material.ambient;\n\n      // diffuse:\n      vec3 light_dir = normalize(lights[i].position.xyz - p.xyz);\n      if(lights[i].position.w < 0.0001) light_dir = normalize(-lights[i].position.xyz); // directional light.\n      float diff = abs(dot(norm, light_dir));\n      vec3 diffuse = lights[i].diffuse * (diff * surfel_color);\n\n      // specular:\n      vec3 reflect_dir = reflect(-light_dir, norm);\n      float spec = pow(max(dot(view_dir, reflect_dir), 0.0), material.shininess);\n      vec3 specular =  lights[i].specular * (spec * material.specular);\n\n      // emission (seems good to apply for each light the emission; with this the emission part doesn't just depend\n      // on the number of lights:\n      result += ambient + diffuse + specular + material.emission;\n    }\n\n     gs_color = vec4(result, alpha);\n  }\n\n  valid = valid && (!backface_culling || (dot(view_dir, n.xyz) > 0));\n\n  if(drawCurrentSurfelsOnly) valid = (gs_in[0].timestamp == timestamp);\n\n  if(surfelDrawMethod == 0 && valid)\n  {\n    vec4 ru = radius * u;\n    vec4 rv = radius * v;\n\n    gl_Position = mvp * (p - ru - rv);\n    texCoords = vec2(-1.0, -1.0);\n    EmitVertex();\n\n    gl_Position =  mvp * (p + ru - rv);\n    texCoords = vec2(1.0, -1.0);\n    EmitVertex();\n\n    gl_Position =  mvp * (p - ru + rv);\n    texCoords = vec2(-1.0, 1.0);\n    EmitVertex();\n\n    gl_Position =  mvp * (p + ru + rv);\n    texCoords = vec2(1.0, 1.0);\n\n    EmitVertex();\n    EndPrimitive();\n  }\n\n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/draw_surfels.vert", "#version 330 core\n\n/**\n *  \author behley\n *\n *  \author Xieyuanli Chen\n **/\n\nlayout (location = 0) in vec4 position_radius;\nlayout (location = 1) in vec4 normal_confidence;\nlayout (location = 2) in int timestamp;\nlayout (location = 3) in vec3 surfel_color_weight_count;\nlayout (location = 4) in vec4 surfel_semantic_map;\n\nuniform mat4 mvp;\nuniform mat4 mvp_inv_t;\n\nuniform samplerBuffer poseBuffer;\n\nout SURFEL\n{\n  float radius;\n  vec4 normal;\n  float confidence;\n  int timestamp;\n  vec3 color;\n  vec4 semantic_map;\n} vs_out;\n\n#include \"shader/color.glsl\"\n\nmat4 get_pose(int timestamp)\n{\n  int offset = 4 * timestamp;\n  return mat4(texelFetch(poseBuffer, offset), texelFetch(poseBuffer, offset + 1),\n              texelFetch(poseBuffer, offset + 2), texelFetch(poseBuffer, offset+3));\n}\n\nvoid main()\n{\n  mat4 surfelPose = get_pose(int(surfel_color_weight_count.z));\n\n  // projection etc is applied in geometry shader.\n  gl_Position = surfelPose * vec4(position_radius.xyz, 1.0f);\n  vs_out.radius = position_radius.w;\n  vs_out.normal = surfelPose * vec4(normal_confidence.xyz, 0.0f);\n  vs_out.confidence = normal_confidence.w;\n  vs_out.timestamp = timestamp;\n  vs_out.color = unpack(surfel_color_weight_count.x);\n  vs_out.semantic_map = surfel_semantic_map;\n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/draw_surfelPoints.vert", "#version 330 core\n\n/**\n *  \author behley\n *\n *  \author Xieyuanli Chen\n **/\n\nlayout (location = 0) in vec4 position_radius;\nlayout (location = 1) in vec4 normal_confidence;\nlayout (location = 2) in int surfel_timestamp;\nlayout (location = 3) in vec3 surfel_color_weight_count;\nlayout (location = 4) in vec4 sfl_semantic_map;\n\nuniform mat4 mvp;\nuniform mat4 mvp_inv_t;\n\nuniform int colorMode; // 0 - phong, 1 - normal shading, 2 - normal color, 3 - confidence\nuniform float conf_threshold;\n\nuniform vec3 view_pos;\nuniform bool drawCurrentSurfelsOnly;\nuniform int timestamp;\nuniform bool backface_culling;\n\nuniform samplerBuffer poseBuffer;\nuniform sampler1D color_map;\n\nout vec4 color;\n\n#include \"shader/color.glsl\"\n\nconst vec4 rviridis = vec4(2.90912735, -2.14404531, 0.04439198,  0.29390206);\nconst vec4 gviridis = vec4(-0.17293242, -0.16906214,  1.24131122,  0.01871256);\nconst vec4 bviridis = vec4(0.17848859, -1.72405244,  1.23042564,  0.34479632);\n\n// approximate version of viridis colormap.\nvec3 viridis(float t)\n{\n  vec4 tt = vec4(t*t*t, t*t, t, 1.0);\n  return vec3(dot(tt, rviridis), dot(tt, gviridis), dot(tt, bviridis));\n}\n\nmat4 get_pose(int timestamp)\n{\n  int offset = 4 * timestamp;\n  return mat4(texelFetch(poseBuffer, offset), texelFetch(poseBuffer, offset + 1),\n              texelFetch(poseBuffer, offset + 2), texelFetch(poseBuffer, offset+3));\n}\n\nvoid main()\n{\n  mat4 surfelPose = get_pose(int(surfel_color_weight_count.z));\n\n\n  // projection etc is applied in geometry shader.\n  gl_Position = mvp * surfelPose * vec4(position_radius.xyz, 1.0f);\n  vec4 n = surfelPose * vec4(normal_confidence.xyz, 0.0f);\n  float c = normal_confidence.w;\n\n  vec4 p =  vec4(position_radius.xyz, 1.0f);\n  vec3 unpacked_color = unpack(surfel_color_weight_count.x);\n\n  bool valid = (c > conf_threshold);\n  vec3 view_dir = normalize((view_pos.xyz - p.xyz));\n\n  if(colorMode == 1)\n  {\n   color = vec4((vec3(.5f, .5f, .5f) * abs(dot(n.xyz, vec3(1.0, 1.0, 1.0)))) + vec3(0.1f, 0.1f, 0.1f), 1.0f);\n  }\n  else if(colorMode == 2)\n  {\n    color = vec4(abs(n.xyz), 1.0f);\n  }\n  else if(colorMode == 3)\n  {\n    valid = true;\n    color = vec4(viridis(1.0-1.0/(1.0 + exp(c))), 1.0);\n  }\n  else if(colorMode == 5)\n  {\n    vec4 semantic_label = vec4(texture(color_map, sfl_semantic_map.x * 255.0f / 259.0f).rgb, 1.0);\n    if (sfl_semantic_map.x != 0) color = semantic_label;\n    else valid = false;\n  }\n  else\n  {\n    vec3 surfel_color = vec3(0.8f, 0.75f, 0.65f);\n    float alpha = 1.0f;\n\n    if (colorMode == 4)\n    {\n      surfel_color = unpacked_color;\n      valid = true;\n      alpha =  1.0 - clamp(conf_threshold - c, 0.1, 1);\n    }\n\n    color = vec4(surfel_color, alpha);\n  }\n\n  valid = valid && (!backface_culling || (dot(view_dir, n.xyz) > 0));\n\n  if(drawCurrentSurfelsOnly) valid = (timestamp == surfel_timestamp);\n\n  if(!valid) gl_Position = vec4(-10, -10, -10, 1.0f);\n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/draw_submaps.vert", "#version 330 core\n\n/**\n *  \author behley\n **/\n\nlayout (location = 0) in vec2 submap_centers;\n\nuniform float submap_extent;\n\nout SUBMAP \n{\n  vec2 center;\n  float extent;  \n} vs_out;\n\n\nvoid main()\n{\n  vs_out.center = submap_centers;\n  vs_out.extent = submap_extent;\n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/draw_submaps.geom", "#version 330 core\n\n/**\n *  \author behley\n **/\n\nlayout(points) in;\nlayout(line_strip, max_vertices = 5) out;\n\nin SUBMAP \n{\n  vec2 center;\n  float extent;  \n} gs_in[];\n\nuniform mat4 mvp;\n\nout vec4 vertexColor;\nuniform float submap_extent;\n\nvoid main()\n{\n    float e = submap_extent;\n    vertexColor = vec4(0,0,0,1);\n    \n    gl_Position = mvp * vec4(gs_in[0].center + vec2(e, e), 0, 1);\n    EmitVertex();\n    \n    gl_Position = mvp * vec4(gs_in[0].center + vec2(e, -e), 0, 1);\n    EmitVertex();\n    \n    gl_Position = mvp * vec4(gs_in[0].center + vec2(-e, -e), 0, 1);\n    EmitVertex();\n    \n    gl_Position = mvp * vec4(gs_in[0].center + vec2(-e, e), 0, 1);\n    EmitVertex();\n    \n    gl_Position = mvp * vec4(gs_in[0].center + vec2(e, e), 0, 1);\n    EmitVertex();\n    \n    EndPrimitive();\n}\n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/coloredvertices.frag", "#version 330 core\n/**\n *  \author behley\n **/\nin vec4 vertexColor;\nout vec4 color;\n\nvoid main()\n{\n    color = vertexColor;\n} \n");
     cache.insertSource("/catkin_ws/src/semantic_suma/src/shader/coloredvertices.vert", "#version 330 core\n/**\n *  \author behley\n **/\n\nlayout (location = 0) in vec4 position_color;\n\nuniform mat4 mvp;\n\nout vec4 vertexColor;\n\nuniform bool useCustomColor;\nuniform vec4 customColor;\n\nvec4 decodeColor(float c)\n{\n    vec4 col;\n    col.x = float(int(c) >> 16 & 0xFF) / 255.0f;\n    col.y = float(int(c) >> 8 & 0xFF) / 255.0f;\n    col.z = float(int(c) & 0xFF) / 255.0f;\n    col.w = 1.0f;\n    \n    return col;\n}\n\nvoid main()\n{\n    gl_Position = mvp * vec4(position_color.xyz, 1.0);\n    vertexColor = decodeColor(position_color.w);\n    if(useCustomColor) vertexColor = customColor;\n}\n");
   };
};

static CacheInitalizer __init__;
} // end namespace computation_shaders